module mc 
	public::  update_energy,init_simdata,init_particle
	
	type, public:: particle
		real*8,dimension(0:30000):: energy ! The energy at each collision
		real*8,dimension(0:30000):: enArr ! The energy target energy at each collision
		integer:: gen ! Which generation the particle was created in
		integer:: colls ! Total number of collisions the particle undergoes
		integer,dimension(0:30000):: state ! The state selected at each collision
		logical,dimension(0:30000):: diss	! True if dissociation occured at that collision
		!real*8,dimension(0:70000):: costheta ! Cosine of the scattering angle at each collision 
                !real*8,dimension(0:70000):: phi     !Azimuthal scattering angle randomly generated after each collision	
		logical,dimension(0:30000):: Ps	! True if Ps Formation occured at that collision (only used for Ps Formation Benchmark Simulation)
                !real*8,dimension(0:70000)::path !Stores path length after each collisions	
                 

                !Stores position and time of particle at each collision. First element is point of creation.
                real*8,dimension(0:30000)::x
                real*8,dimension(0:30000)::y
                real*8,dimension(0:30000)::z
                real*8,dimension(0:30000)::time
 
                !Stores unit vectors in coordinate system attached to each collision,
                !where the new zHat is along the final particle trajectory.
                real*8, dimension(3)::xHat
                real*8, dimension(3)::yHat
                real*8, dimension(3)::zHat
	end type particle
	
	type, public:: simdata ! Data for the simulation of ONE incident particle
	
		integer:: secE ! total number of secondary electrons created in this simulation (num of ionisations)		
		integer:: excite ! total number of excitation collisions created in this simulation
		integer:: elastic ! total number of elastic collisions created in this simulation
		integer:: dissociations ! total number of dissociations in this simulation
		integer:: gen ! total number of sec E generations created in this simulation
		integer:: genIndex ! Current generation 
                real*8:: inERad  !Final radial distance of the incident electron
                integer:: B1SuExc  !total number of excitations of the B1Su state of H2 in this simulation
                integer:: C1PuExc     !total number of excitations of the C1Pu state of H2 in this simulation
                integer:: singletExc  !total number of singlet H2 excitations in this simulation
                integer:: tripletExc !total number of triplet H2 excitations in this simulation
		integer,dimension(1000):: ePerGen ! Number of electrons in each generation
		real*8,dimension(1000):: enPerGen ! Total energy of electrons in each generation
		integer,dimension(0:1000):: dissPerGen ! Dissociation count per generation
		!integer,dimension(0:1000):: ionPerGen ! number of ionisations in each gen 
		integer,dimension(0:1000):: excPerGen ! number of excitation collisions in each gen
		integer,dimension(0:1000):: elPerGen ! number of elastic collisions in each gen 
		integer,dimension(0:1000):: collPerGen ! number of collisions in each gen 
	       
                !Data recorded for program consistency checks
                real*8, dimension(0:1000):: ejEnGrid !Grid of ejection energies in ionisation
                integer,dimension(0:1000):: numEj !Number of ionisations at a given energy in above grid 	
				
		! For Ps Benchmark Simulation
		logical:: PsFormed ! True if Positronium is Formed (exit condition for simulation loop)
		integer:: numPsFormed
		real*8 :: duration,tResTemp,tRes

                !Newer energy deposition parameters
                real*8:: W   !Energy per ion pair 
                real*8:: singIonPair  !Singlet excitations per ion pair 
                real*8:: tripIonPair  !Triplet excitations per ion pair
                real*8:: B1SuIonPair  !B1Su excitations per ion pair
                real*8:: C1PuIonPair  !C1Pu excitations per ion pair

                !Data used for error analysis, collected over a large number of runs
                !of the simulation
                integer:: numSims   !number of simulations run
                real*8:: msecE     !mean values of simulation outputs
                real*8:: mW
                real*8:: mexcite 
                real*8:: mdissociations
                real*8:: mgen 
                real*8:: minERad 
                real*8:: mB1SuExc 
                real*8:: mC1PuExc
                real*8:: msingletExc  
                real*8:: mtripletExc  
                real*8:: mSingIonPair
                real*8:: mTripIonPair
                real*8:: mB1SuIonPair
                real*8:: mC1PuIonPair
  
                !Mean square values of simulation outputs
                real*8:: mssecE 
                real*8:: msW
                real*8:: msexcite 
                real*8:: msdissociations
                real*8:: msgen 
                real*8:: msinERad 
                real*8:: msB1SuExc
                real*8:: msC1PuExc 
                real*8:: mssingletExc 
                real*8:: mstripletExc 		
                real*8:: msSingIonPair
                real*8:: msTripIonPair
                real*8:: msB1SuIonPair
                real*8:: msC1PuIonPair
 
	end type simdata
	
	contains
	
	subroutine init_particle(self,initE,gen,xIn,yIn,zIn,tIn) ! Initialise particle values
	
		type(particle),intent(inout):: self
		real*8,intent(in):: initE
		integer,intent(in):: gen
                real*8::xIn, yIn, zIn, tIn !Initial particle coordinates
		
	        self%energy(:) = 0.0
		self%state(:) = 0
		self%diss(:) = .FALSE.
		!self%costheta(:) = 0.0
		self%Ps(:) = .FALSE.
                !self%path(:) = 0.0
				
		self%energy(0) = initE
		self%gen = gen		
		self%colls = 0

                self%x(0) = xIn
                self%y(0) = yIn
                self%z(0) = zIn
                self%time(0) = tIn

                self%xHat(1) = 1.0
                self%xHat(2) = 0.0
                self%xHat(3) = 0.0
                self%yHat(1) = 0.0
                self%yHat(2) = 1.0
                self%xHat(3) = 0.0
                self%zHat(1) = 0.0
                self%zHat(2) = 0.0
                self%zHat(3) = 1.0
	end subroutine init_particle
	
	
	subroutine init_simdata(self) ! Initialise data for ONE simulation
	
		implicit none
		type(simdata), intent(inout):: self
		integer:: i
                real*8:: en	
	
		self%secE = 0
		self%gen = 0
		self%excite = 0
		self%elastic = 0
		self%dissociations = 0
		
		self%PsFormed = .false.
		self%numPsFormed = 0
		self%duration = 0.0
		self%tResTemp = 0.0
		self%tRes = 0.0
                
                self%B1SuExc = 0
                self%C1PuExc = 0
                self%singletExc = 0
                self%tripletExc = 0		

		do i = 1,1000
			self%ePerGen(i) = 0
			self%enPerGen(i) = 0.0
		end do
		
		do i = 0,1000
			self%dissPerGen(i) = 0
			!self%ionPerGen(i) = 0
			self%excPerGen(i) = 0
			self%elPerGen(i) = 0
			self%collPerGen(i) = 0
		end do

                en = 0.0
                do i =1, 1000
                   self%ejEnGrid(i) = en
                   en = en + 0.5
                end do
                self%numEj(:) = 0

                self%W = 0.0d0 
                self%singIonPair = 0.0d0
                self%tripIonPair = 0.0d0
                self%B1SuIonPair = 0.0d0
                self%C1PuIonPair = 0.0d0

                self%msecE = 0.0d0
                self%mW = 0.0d0
                self%mexcite = 0.0d0
                self%mdissociations = 0.0d0
                self%mgen = 0.0d0
                self%minERad = 0.0d0
                self%mB1SuExc = 0.0d0
                self%mC1PuExc = 0.0d0
                self%msingletExc = 0.0d0
                self%mtripletExc = 0.0d0
                self%mSingIonPair = 0.0d0
                self%mTripIonPair = 0.0d0
                self%mB1SuIonPair = 0.0d0
                self%mC1PuIonPair = 0.0d0

                self%mssecE = 0.0d0
                self%msW = 0.0d0
                self%msexcite = 0.0d0
                self%msdissociations = 0.0d0
                self%msgen = 0.0d0
                self%msinERad = 0.0d0
                self%msB1SuExc = 0.0d0
                self%msC1PuExc = 0.0d0
                self%mssingletExc = 0.0d0
                self%mstripletExc = 0.0d0
                self%msSingIonPair = 0.0d0
                self%msTripIonPair = 0.0d0
                self%msB1SuIonPair = 0.0d0
                self%msC1PuIonPair = 0.0d0

	end subroutine init_simdata


   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   !Subroutine: recordEjEn
   !Purpose: records the ejection energy chosen using one of several
   !         distributions for ionisation.
   !Date last modified: 15/07/2020
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   subroutine recordEjEn(energy, datasim)
       implicit none
       type(simdata)::datasim
       real*8:: energy
       logical:: found
       integer:: ii

       found = .false.
       !Find energy range in grid chosen energy falls into
       
       ii = 1
       do while (.not. found)
          if (energy .gt. datasim%ejEnGrid(ii)) then
             ii = ii + 1
          else 
             found = .true.
          end if 
       end do
           
       !Increment number in a particular range
       datasim%numEj(ii) = datasim%numEj(ii) +1
   end subroutine recordEjEn



	
    subroutine update_energy(statebasis,sdcsBasis,dcsBasis,stateNum,tcs,particlebasis,minExcEn,partNum,cosangle,coll,ionop,enlossop,datasim,bmode,VarPs)
        use state_class
        use totalcs_module
        use Ps_module
        use sdcs_module
        use input_data
        use dcs_module
        implicit none
		
	type(basis_state),intent(in):: statebasis
	type(state):: selstate
        type(basis_sdcs)::sdcsBasis
        !type(basis_vcs)::vcsBasis
        type(sdcs)::sdcsAtEIn
        !type(vcs)::vcsIn
	integer, intent(in):: stateNum
	type(particle),dimension(0:1000),intent(inout):: particlebasis
	integer,intent(in):: partNum,coll, enlossop
	character (len=60),intent(in):: ionop ! Ionistation option
	type(totalcs):: tcs ! used to calculate the mean excitation energy
	type(simdata), intent(inout):: datasim		
	real*8:: enex,en ! excitation and ionisation energy (eV)
        real*8:: enexVib ! vibrational excitation energy
	real*8:: meanexc ! mean excitation energy (eV)
	real*8:: elEnergyLoss	  ! energy lost by incident particle (eV)
        real*8:: inElEnergyLoss   !energy loss in inelastic scattering, includes internal energy
        real*8:: ejEn, secE, primaryE, eIon, ejEnSelected, eIn,cosangle
        real*8:: minExcEn !Minimum target electron excitation energy
        logical:: indist
	! For Ps Benchmark Simulation
	type(PsVar),intent(in):: VarPs 
	logical,intent(in):: bmode
        ! For debugging
        integer:: stateNumDebug
        logical:: debug
        type(totalcs)::tcsDebug
        type(sdcs)::sdcsDebug		
        type(basis_dcs)::dcsBasis
        debug = .false.
        
        eIon = 15.96632 !Ionisation energy of ground state H2 (eV)	
        eIn = particlebasis(partNum)%energy(coll)

	! The state that has been selected
        !Note that tcs stores energy in a.u, not eV
        en = 0.0
        if (data_in%stateIonop .eq. 1) then
           !Use symmetrised pseudostates
           if (tcs%en(stateNum)*data_in%eV .lt. 0.0) then
              selstate = statebasis%b(stateNum) 
   	      enex =  selstate%enex
    	      en = selstate%en
           else if (tcs%en(stateNum)*data_in%eV .gt. 0.0) then
              en = tcs%en(stateNum)*data_in%eV
           end if
        else if (data_in%stateIonop .eq. 0) then 
           selstate = statebasis%b(stateNum) 
           enex =  selstate%enex
           en = selstate%en
        end if
        call getIndist(bmode,indist) 	


	!print*, 'particle',partNum,'gen',particlebasis(partNum)%gen,'coll',coll
	!print*, 'enex',enex
	!print*, 'preCollEnergy',particlebasis(partNum)%energy(coll)
	
	!print*, 'el cs', tcs%CS(1)
	!print*, 'exc cs', tcs%CS(2)
	!print*, 'ion cs', tcs%CS(3)
	!print*, 'Ps cs', tcs%CS(4)
        particlebasis(partNum)%enArr(coll) = en


	if (stateNum == 1) then ! elastic collision					
	   datasim%elastic = datasim%elastic + 1	! Update total elastic scattering count for this simulation
	   datasim%elPerGen(particlebasis(partNum)%gen) = datasim%elPerGen(particlebasis(partNum)%gen) + 1 ! Update total elastic scattering count for this generation
	   call elasticScattering(particlebasis(partNum)%energy(coll),cosangle,elEnergyLoss,bmode,dcsBasis) 
	   particlebasis(partNum)%energy(coll + 1) = particlebasis(partNum)%energy(coll) - elEnergyLoss 
				
	else if(en < 0) then ! excitation collision 
	   datasim%excite = datasim%excite + 1 
	   datasim%excPerGen(particlebasis(partNum)%gen) = datasim%excPerGen(particlebasis(partNum)%gen) + 1 ! Update total excitation count for this generation
           call update_H2Data(datasim, stateBasis, stateNum)
			
	   if(bmode) then
	      call elasticScattering(particlebasis(partNum)%energy(coll),cosangle,elEnergyLoss,bmode,dcsBasis) 
	      particlebasis(partNum)%energy(coll + 1) = particlebasis(partNum)%energy(coll) - enex - elEnergyLoss
	   else
              if (enlossop .eq. 1) then
                 !Use only excitation energy of selected state                 
	         particlebasis(partNum)%energy(coll + 1) = particlebasis(partNum)%energy(coll) - enex
              else if (enlossop .eq. 2) then
                 !Use inelastic formula 
                 call inelasticScattering(particlebasis(partNum)%energy(coll),enex,cosangle,inElEnergyLoss,bmode) 	
                 !Formula used for inelastic scattering includes loss
                 !to internal energy.
                 particlebasis(partNum)%energy(coll + 1) = particlebasis(partNum)%energy(coll) - inElEnergyLoss
              end if
	   end if	
	
        else if((stateNum .gt. 1) .and. (en > 0)) then ! ionisation collision 
	   datasim%secE = datasim%secE + 1 ! Increment number of secondary electrons created
	   datasim%gen = particlebasis(partNum)%gen + 1 ! Keep track of the number of generations that have been created
           datasim%ePerGen(particlebasis(partNum)%gen + 1) = datasim%ePerGen(particlebasis(partNum)%gen+1) + 1 ! Keep track of number of electrons in the next generation
			
	   if(bmode) then	! Only for Ps Benchmark Simulation
	      particlebasis(partNum)%energy(coll + 1) = VarPs%Q * (particlebasis(partNum)%energy(coll) - VarPs%e_ion)
	      !print*, 'Q',VarPs%Q
	   else ! For Default Simulation
              if(data_in%stateIonop .eq. 1) then
                 !Symmetrise totalcs

                 !tcs object energy grid in Hartees, need to convert
                 enex = tcs%en(stateNum)*data_in%eV
              end if

	      if(ionop.EQ.'mean') then ! mean excitation energy will be used
	         call meanexcenergy(tcs,statebasis,meanexc)

                 !Note; don't need to deal with indistinguishibility yet, as meanexc is
                 !      always below (eIn-eIon)/2.0
                 !ejEnSelected = meanexc
                 !Deal with particle indistinguishibility		
                 !if (indist) then
                 !   if (ejEnSelected .gt. (eIn-eIon)/2.0) then
                    !Above cutoff energy, energy selected is that of incident e        
                 !      secE = eIn-ejEnSelected
                 !      primaryE = ejEnSelected-eIon
                 !   else 
                 !      secE = ejEnSelected-eIon
                 !      primaryE = eIn-ejEnselected
                 !   end if
                 !end if

                 !particlebasis(partNum)%energy(coll+1) = primaryE 
		 !call init_particle(particlebasis(datasim%secE),secE,particlebasis(partNum)%gen + 1)			
		 !datasim%enPerGen(particlebasis(partNum)%gen + 1) = datasim%enPerGen(particlebasis(partNum)%gen+1) + secE

	         particlebasis(partNum)%energy(coll + 1) = particlebasis(partNum)%energy(coll) - meanexc
	         ! sec E created with energy equal to the mean exc energy minus the ionisation potential, its generation is the one after the current generation
		 call init_particle(particlebasis(datasim%secE),meanexc-eIon,particlebasis(partNum)%gen + 1,particlebasis(partNum)%x(coll),particlebasis(partNum)%y(coll),&
                                    particlebasis(partNum)%z(coll),particlebasis(partNum)%time(coll))		
		 datasim%enPerGen(particlebasis(partNum)%gen + 1) = datasim%enPerGen(particlebasis(partNum)%gen+1) + (meanexc-eIon)
			
		 ! if((partNum.eq.0) .and.(coll.eq.0)) then
		   ! call meanexcenergy(tcs,statebasis,meanexc)
		 ! end if
                 !ejEnSelected = meanexc - eIon
	      else if(ionop .EQ. 'state_distribution') then ! regular excitation energy will be used 
                 !Particle loses energy of pseudostate, subject to indistinguishability
                 !print*, 'enex', enex
                 !Use alternate method to select ejection energy from CCC CS

                 !Get pseudostates at the given incident energy


                 !Symmetrise them

                 !Select positive energy state.




                     
                 if (enlossop .eq. 1) then
                    !Deal with indistinguishibility
                    ejEnSelected = enex
                    !print*, "IN:", eIn, "SEL:",ejEnSelected
                    if (indist) then
                       if (ejEnSelected .gt. (eIn-eIon)/2.0) then
                          !Above cutoff energy, energy selected is that of incident e       
                          secE = eIn-ejEnSelected-eIon
                          primaryE = ejEnSelected
                       else 
                          secE = ejEnSelected
                          primaryE = eIn-ejEnselected-eIon
                       end if
                    else
                       secE = enex-eIon
                       primaryE = eIn-enex
                    end if

	            particlebasis(partNum)%energy(coll + 1) = primaryE
	            !particlebasis(partNum)%energy(coll + 1) = particlebasis(partNum)%energy(coll) - enex
                 else if (enlossop .eq. 2) then
                    !Include recoil for inelastic collisions

                    !Deal with indistinguishibility
                    ejEnSelected = enex
                    if (indist) then
                       if (ejEnSelected .gt. (eIn-eIon)/2.0) then
                          !Above cutoff energy, energy selected is that of incident e        
                          call inelasticScattering(particlebasis(partNum)%energy(coll),eIn-enex,cosangle,inElEnergyLoss,bmode)
                          secE = eIn-enex
                          primaryE = eIn-inElEnergyLoss 
                       else 
                          call inelasticScattering(particlebasis(partNum)%energy(coll),enex,cosangle,inElEnergyLoss,bmode)
                          secE = enex
                          primaryE = eIn-inElEnergyLoss
                       end if
                    else
                       call inelasticScattering(particlebasis(partNum)%energy(coll),enex,cosangle,inElEnergyLoss,bmode)
                       secE = enex-eIon
                       primaryE = eIn-inElEnergyLoss
                    end if
                    particlebasis(partNum)%energy(coll+1) = primaryE
                    !call inelasticScattering(particlebasis(partNum)%energy(coll),enex,particlebasis(partNum)%costheta(coll),inElEnergyLoss,bmode)
                    !particlebasis(partNum)%energy(coll+1) = particlebasis(partNum)%energy(coll) - inElEnergyLoss
                 end if
	         call init_particle(particlebasis(datasim%secE),secE,particlebasis(partNum)%gen + 1,particlebasis(partNum)%x(coll),particlebasis(partNum)%y(coll),&
                                    particlebasis(partNum)%z(coll), particlebasis(partNum)%time(coll))
                 call recordEjEn(secE,datasim)
	         datasim%enPerGen(particlebasis(partNum)%gen + 1) = datasim%enPerGen(particlebasis(partNum)%gen+1) + secE

                 !ejEnSelected = en
	         ! sec E created with energy equal to positive cont. ionisation energy, its generation is the one after the current generation
	         !call init_particle(particlebasis(datasim%secE),en,particlebasis(partNum)%gen + 1)
                 !call recordEjEn(en,datasim)
	         !datasim%enPerGen(particlebasis(partNum)%gen + 1) = datasim%enPerGen(particlebasis(partNum)%gen+1) + en
	      else if(ionop .EQ. 'SDCS') then !Distribution from SDCS
                 !Instead fit all SDCS in preprocessing ig sdcsOp .eq. 1 
                 !if(data_in%SdcsOp .eq. 0) then
                 !   call get_sdcsatein(sdcsBasis,particlebasis(partNum)%energy(coll),sdcsAtEIn)
                 !else if (data_in%SdcsOp .eq. 1) then 
                 !   call get_sdcsateinfit(sdcsAtEIn,sdcsBasis,particlebasis(partNum)%energy(coll),stateBasis,data_in)
                 !May need to update for more general non-H2 case
                 !end if
 
                 call get_sdcsatein(sdcsBasis,particlebasis(partNum)%energy(coll),sdcsAtEIn)


                 if (debug) then
                    allocate(tcsDebug%CS(sdcsAtEIn%Ncgsdcs))
                    allocate(tcsDebug%en(sdcsAtEIn%Ncgsdcs))
                    tcsDebug%cs(:) = sdcsAtEIn%CS(:)
                    tcsDebug%en(:) = sdcsAtEIn%ecg(:) 
                    call selectstate(tcsDebug,particlebasis(partNum),coll,stateNumDebug)
                    ejEn = tcsDebug%en(stateNumDebug)
                    deallocate(tcsDebug%CS,tcsDebug%en)
                 else 
                    !Choose ejection energy, run monte carlo
                    call selectEjEn(sdcsAtEIn,ejEn) 
                 end if

                 !Deal with indistinguishability
                 ejEnSelected = ejEn	        
                 if (indist)  then
                    if (ejEnSelected .gt. (eIn-eIon)/2.0) then
                       !Above cutoff energy, energy selected is that of incident e        
                       secE = eIn-ejEnSelected-eIon
                       primaryE = ejEnSelected
                    else 
                       secE = ejEnSelected
                       primaryE = eIn-ejEnSelected-eIon
                    end if
                 else
                    secE = ejEn
                    primaryE = eIn-ejEnSelected-eIon
                 end if
                  
                 particlebasis(partNum)%energy(coll+1) = primaryE
	         call init_particle(particlebasis(datasim%secE),secE,particlebasis(partNum)%gen+1,particlebasis(partNum)%x(coll),particlebasis(partNum)%y(coll),&
                                    particlebasis(partNum)%z(coll), particlebasis(partNum)%time(coll))
                 datasim%enPerGen(particlebasis(partNum)%gen + 1) = datasim%enPerGen(particlebasis(partNum)%gen+1) + secE

                 !particlebasis(partNum)%energy(coll + 1) = particlebasis(partNum)%energy(coll) - (ejEn + eIon)				
	         !call init_particle(particlebasis(datasim%secE),ejEn,particlebasis(partNum)%gen + 1)
                 !datasim%enPerGen(particlebasis(partNum)%gen + 1) = datasim%enPerGen(particlebasis(partNum)%gen+1) + ejEn
                 call destructSdcsAtEIn(sdcsAtEIn)
                 call recordEjEn(secE,datasim)
                 !call recordEjEn(ejEn,datasim) !Record ejection energy chosen
              else if (ionop .eq. 'SDCSDist') then
                 !Use analytical distribution from Dalgarno paper
                 call getSdcsDistAtEIn(sdcsBasis,eIn,sdcsAtEIn,tcs,stateBasis)
                 call selectEjEn(sdcsAtEIn, ejEn) 
  
                 !print*, "EJEN: ", ejEn
                 !Deal with indistinguishability
                 !Use same method as symmetrised SDCS for consistency
                 ejEnSelected = ejEn	        
                 if (indist)  then
                    if (ejEnSelected .gt. (eIn-eIon)/2.0) then
                       !Above cutoff energy, energy selected is that of incident e        
                       secE = eIn-ejEnSelected-eIon
                       primaryE = ejEnSelected
                    else 
                       secE = ejEnSelected
                       primaryE = eIn-ejEnSelected-eIon
                    end if
                 else
                    secE = ejEn
                    primaryE = eIn-ejEnSelected-eIon
                 end if
 
                 particlebasis(partNum)%energy(coll+1) = primaryE
	         call init_particle(particlebasis(datasim%secE),secE,particlebasis(partNum)%gen + 1,particlebasis(partNum)%x(coll),particlebasis(partNum)%y(coll), &
                                    particlebasis(partNum)%z(coll), particlebasis(partNum)%time(coll))
                 datasim%enPerGen(particlebasis(partNum)%gen + 1) = datasim%enPerGen(particlebasis(partNum)%gen+1) + secE
 
                 call destructSdcsAtEIn(sdcsAtEIn)
                 call recordEjEn(secE,datasim)
              end if
           end if	
           !particlebasis(partNum)%energy(coll+1) = primaryE
           !call init_particle(particlebasis(datasim%secE),secE,particlebasis(partNum)%gen+1)               
           !datasim%enPerGen(particlebasis(partNum)%gen + 1) = datasim%enPerGen(particlebasis(partNum)%gen+1) + secE
           !call recordEjEn(secE,datasim) !Record ejection energy chosen
        else
	   !write to an error file
        end if	
        !print*, 'postCollEnergy',particlebasis(partNum)%energy(coll + 1) 	
    end subroutine update_energy










    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !Subroutine: update_position
    !Purpose: updates the position of the scattered particle and
    !         orientation of the coordinate system.
    !Date last modified: 02/02/2021
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    subroutine update_position(particleIn,rad,costheta,phi,coll,datasim)
        implicit none
        type(simdata)::datasim
        type(particle)::particleIn
        real*8::rad,costheta,phi,theta
        real*8::xVal,yVal,zVal
        real*8, dimension(3,3)::rotMat
        integer::coll

        theta = ACOS(costheta)       

        !Construct rotation matrix from theta, phi using analytic formulae
        rotMat(1,1) = costheta*cos(phi)
        rotMat(1,2) = -sin(theta)
        rotMat(1,3) = costheta*sin(phi)
        rotMat(2,1) = sin(theta)*cos(phi)
        rotMat(2,2) = costheta
        rotMat(2,3) = sin(theta)*sin(phi)
        rotMat(3,1) = -sin(phi)
        rotMat(3,2) = 0.0
        rotMat(3,3) = cos(phi)

        !Rotate coordinate system. 
        particleIn%zHat = MATMUL(rotMat,particleIn%zHat)
        particleIn%yHat = MATMUL(rotMat,particleIn%yHat) 
        particleIn%xHat = MATMUL(rotMat,particleIn%xhat)

        !Calculate new position
        particleIn%x(coll+1) = particleIn%x(coll) + rad*particleIn%zHat(1)
        particleIn%y(coll+1) = particleIn%y(coll) + rad*particleIn%zHat(2)
        particleIn%z(coll+1) = particleIn%z(coll) + rad*particleIn%zHat(3)

        xVal = particleIn%x(coll+1)
        yVal = particleIn%y(coll+1)
        zVal = particleIn%z(coll+1)

        !Update incident particle distance from origin
        datasim%inERad = SQRT(xVal**2+yVal**2+zVal**2)

    end subroutine update_position




   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   !Subroutine: update_H2Data
   !Purpose: updates how many excitations of states of interest
   !         of H2 have occured based on the selected stateNum 
   !Date last modified: 03/05/2021
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   subroutine update_H2Data(datasim, stateBasis, stateNum)
       use state_class
       implicit none
       type(simdata)::datasim
       type(basis_state)::stateBasis
       integer:: stateNum
 
       if (stateNum .eq. 6) then
          if ((stateBasis%b(6)%spin .eq. 0) .and. (stateBasis%b(6)%ipar .eq. -1) &
             .and. (stateBasis%b(6)%m .eq. 0)) then 
             datasim%B1SuExc = datasim%B1SuExc +1
          else
             print*, "ERROR: invalid state, stopping: update_H2Data"
             stop
          end if
       else if ((stateNum .eq. 8) .or. (stateNum .eq. 9)) then
          if ((stateBasis%b(stateNum)%spin .eq. 0) .and. (stateBasis%b(stateNum)%ipar .eq. -1) &
             .and. (abs(stateBasis%b(stateNum)%m) .eq. 1)) then 
             datasim%C1PuExc = datasim%C1PuExc +1
          else
             print*, "ERROR: invalid state, stopping: update_H2Data"
             stop
          end if
       end if

       if (statebasis%b(stateNum)%spin .eq. 0) then
          datasim%singletExc = datasim%singletExc + 1 
       else if (statebasis%b(stateNum)%spin .eq. 1) then
          datasim%tripletExc = datasim%tripletExc + 1
       end if 

   end subroutine update_H2Data












    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !Subroutine: getIndist
    !Purpose: indentifies whether or not scattered particles are
    !         indistinguishible
    !Date last modified: 20/09/2020
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    subroutine getIndist(bmode,indist)
        implicit none
        logical, intent(inout)::indist
        logical, intent(in):: bmode

        indist = .false.
        if (.not. bmode) then
           indist = .true.
        end if
    end subroutine

	
	subroutine dissociation(part,statebasis,stateNum,dicsBasis,tcs,datasim,data_input,coll)
                use input_data
                use state_class
		use totalcs_module	
		implicit none
		
                type(input)::data_input
		type(particle),intent(inout):: part
		type(totalcs),intent(in):: tcs
                type(basis_state),intent(in)::statebasis
		integer,intent(in):: stateNum, coll
                type(basis_dics),intent(in)::dicsBasis
                type(state)::selstate
		type(simdata), intent(inout):: datasim		
		logical:: diss	! True if dissociation occurs
		real*8:: df, randNum, en, enIncident
                	
                enIncident = part%energy(coll)

                !Find energy of selected state
                if (data_in%stateIonop .eq. 1) then
                   en = tcs%en(stateNum)  
                else if (data_in%stateIonop .eq. 0) then
                   selstate = statebasis%b(stateNum)
                   en = selstate%en
	        end if
           
		! Assume dissociation does not occur until proven otherwise
		diss = .FALSE.		
                df = 0.0   

                if (data_input%benchmarkOp .eq. 1) then
                   !Dissociation not considered
                else 
  	   	   ! Get the dissociation fraction for selected state at current energy
                   if (data_input%dicsop .eq. 1) then
                      df = tcs%df(stateNum)
                   else if (data_input%dicsop .eq. 2) then
                      if (en <0) then	
                         !excitation collision
	   	         df = tcs%df(stateNum)
                      else if (en >0) then
                         !Ionisation collision uses dissociative 
                         !ionisation cross sections.            
                         call getDissIonDf(dicsBasis, enIncident, df)
                      end if
                   end if		
                end if


		! Random Number is selected between 0 and 1
		call RANDOM_NUMBER(randNum)
		
		! Sample to see if dissociation occurs
		if(randNum .lt. df) then
		   diss = .TRUE.
                   part%diss(coll) = 1
                else
                   part%diss(coll) = 0 
		end if		
		
		!print*, 'df = ', df
		!print*, 'randNum = ', randNum
		!print*, 'diss = ', diss
		part%diss(part%colls) = diss		
		if(diss .eqv. .true.) then ! Update how many dissociations have occured for this generation.
			datasim%dissPerGen(part%gen) = datasim%dissPerGen(part%gen) + 1
			datasim%dissociations = datasim%dissociations + 1
		end if
		!print*, 'diss tally ',datasim%dissPerGen(part%gen)
	
		
	end subroutine dissociation


	
	subroutine collectdata(datasim,maxgen,datamc,data_input)
	 use input_data
	 implicit none
	 integer,intent(in):: maxgen
         type(input):: data_input
	 type(simdata),intent(in):: datasim
	 type(simdata),intent(inout):: datamc
	 integer:: i

	 datamc%secE = datamc%secE + datasim%secE
	 datamc%excite = datamc%excite + datasim%excite
	 datamc%elastic = datamc%elastic + datasim%elastic
	 datamc%gen = datamc%gen + datasim%gen
	 datamc%dissociations = datamc%dissociations + datasim%dissociations
         datamc%inERad = datamc%inERad + datasim%inERad
      
         datamc%B1SuExc = datamc%B1SuExc + datasim%B1SuExc	
         datamc%C1PuExc = datamc%C1PuExc + datasim%C1PuExc
         datamc%singletExc = datamc%singletExc + datasim%singletExc
         datamc%tripletExc = datamc%tripletExc + datasim%tripletExc 
         !New parameters
         datamc%W = datamc%W + data_input%energyeV/dble(datasim%secE)
         datamc%singIonPair = datamc%singIonPair + dble(datasim%singletExc)/dble(datasim%secE)
         datamc%tripIonPair = datamc%tripIonPair + dble(datasim%tripletExc)/dble(datasim%secE)
         datamc%B1SuIonPair = datamc%B1SuIonPair + dble(datasim%B1SuExc)/dble(datasim%secE)
         datamc%C1PuIonPair = datamc%C1PuIonPair + dble(datasim%C1PuExc)/dble(datasim%secE)
 
	 do i=1,maxgen
		datamc%ePerGen(i) = datamc%ePerGen(i) + datasim%ePerGen(i) 
		datamc%enPerGen(i) = datamc%enPerGen(i) + datasim%enPerGen(i)
	 end do	 
	 
	 do i=0,maxgen
		datamc%dissPerGen(i) = datamc%dissPerGen(i) + datasim%dissPerGen(i) 
		datamc%excPerGen(i) = datamc%excPerGen(i) + datasim%excPerGen(i) 
		datamc%elPerGen(i) = datamc%elPerGen(i) + datasim%elPerGen(i) 
		datamc%collPerGen(i) = datamc%collPerGen(i) + datasim%collPerGen(i) 
	 end do	 
	 
	 if(datasim%PsFormed) then
		datamc%numPsFormed = datamc%numPsFormed + 1
	 end if
	
         !Consistency check data
         do i =1, 1000
            datamc%numEj(i) = datamc%numEj(i) + datasim%numEj(i) 
         end do

         !Update mean and mean square of recorded values, these are used 
         !to calculate statistical uncertainty in the 
         !output of the simulation
         datamc%msecE = datamc%msecE + dble(datasim%secE)/dble(datamc%numSims)
         datamc%mW = datamc%mW + (dble(data_input%energyeV)/dble(datasim%secE))/dble(datamc%numSims)
         datamc%mexcite = datamc%mexcite + dble(datasim%excite)/dble(datamc%numSims)
         datamc%mdissociations = datamc%mdissociations + dble(datasim%dissociations)/dble(datamc%numSims)
         datamc%mgen = datamc%mgen + dble(datasim%gen)/dble(datamc%numSims)
         datamc%minERad = datamc%minERad + dble(datasim%inERad)/dble(datamc%numSims)
         datamc%mB1SuExc = datamc%mB1SuExc + dble(datasim%B1SuExc)/dble(datamc%numSims)
         datamc%mC1PuExc = datamc%mC1PuExc + dble(datasim%C1PuExc)/dble(datamc%numSims)
         datamc%msingletExc = datamc%msingletExc + dble(datasim%singletExc)/dble(datamc%numSims)
         datamc%mtripletExc = datamc%mtripletExc + dble(datasim%tripletExc)/dble(datamc%numSims)
         datamc%mSingIonPair = datamc%mSingIonPair + dble(datasim%singletExc)/dble(datasim%secE*datamc%numSims) 
         datamc%mTripIonPair = datamc%mTripIonPair + dble(datasim%tripletExc)/dble(datasim%secE*datamc%numSims)
         datamc%mB1SuIonPair = datamc%mB1SuIonPair + dble(datasim%B1SuExc)/dble(datasim%secE*datamc%numSims)
         datamc%mC1PuIonPair = datamc%mC1PuIonPair + dble(datasim%C1PuExc)/dble(datasim%secE*datamc%numSims)

         datamc%mssecE = datamc%mssecE + (dble(datasim%secE)**2)/dble(datamc%numSims)
         datamc%msW = datamc%msW + (dble(data_input%energyeV)/dble(datasim%secE))**2/dble(datamc%numSims)
         datamc%msexcite = datamc%msexcite + (dble(datasim%excite)**2)/dble(datamc%numSims)
         datamc%msdissociations = datamc%msdissociations + (dble(datasim%dissociations)**2)/dble(datamc%numSims)
         datamc%msgen = datamc%msgen + (dble(datasim%gen)**2)/dble(datamc%numSims)
         datamc%msinERad = datamc%msinERad + (dble(datasim%inERad)**2)/dble(datamc%numSims)
         datamc%msB1SuExc = datamc%msB1SuExc + (dble(datasim%B1SuExc)**2)/dble(datamc%numSims)
         datamc%msC1PuExc = datamc%msC1PuExc + (dble(datasim%C1PuExc)**2)/dble(datamc%numSims)
         datamc%mssingletExc = datamc%mssingletExc + (dble(datasim%singletExc)**2)/dble(datamc%numSims)
         datamc%mstripletExc = datamc%mstripletExc + (dble(datasim%tripletExc)**2)/dble(datamc%numSims)
         datamc%msSingIonPair = datamc%msSingIonPair + ((dble(datasim%singletExc)/dble(datasim%secE))**2)/dble(datamc%numSims) 
         datamc%msTripIonPair = datamc%msTripIonPair + ((dble(datasim%tripletExc)/dble(datasim%secE))**2)/dble(datamc%numSims)
         datamc%msB1SuIonPair = datamc%msB1SuIonPair + ((dble(datasim%B1SuExc)/dble(datasim%secE))**2)/dble(datamc%numSims)
         datamc%msC1PuIonPair = datamc%msC1PuIonPair + ((dble(datasim%C1PuExc)/dble(datasim%secE))**2)/dble(datamc%numSims)

      end subroutine collectdata 

	
	subroutine printsim(simIndex,particlebasis,datasim,bmode)
	
		implicit none
		integer,intent(in):: simIndex
		type(particle),dimension(0:1000),intent(in):: particlebasis
		type(simdata),intent(in):: datasim
		logical,intent(in):: bmode ! True if Ps Benchmark Simulation is being done
		integer:: partNum,coll
	
		write(60,*) '-------------------------------- NEW SIMULATION ---------------------------'
		write(60,*) 'simIndex',simIndex
		do partNum=0, datasim%secE   
			if((.not. bmode) .or. (bmode.and.(partNum.eq.0))) then
				write(60,*) '--------NEW PARTICLE--------'
				write(60,*) 'particle',partNum,'gen',particlebasis(partNum)%gen
				do coll=0,particlebasis(partNum)%colls
					write(60,*) '-------'
					write(60,*) 'coll',coll,'state',particlebasis(partNum)%state(coll)
					write(60,*) 'precollE',particlebasis(partNum)%energy(coll),'postE', particlebasis(partNum)%energy(coll+1)	
					if(bmode) then
						write(60,*) 'Ps Formation = ', particlebasis(partNum)%Ps(coll)
					else
						write(60,*) 'diss = ', particlebasis(partNum)%diss(coll)
					end if
				end do
			end if
		end do
		write(60,*) 'ions',datasim%secE
		write(60,*) 'elastic', datasim%elastic
		write(60,*) 'excite',datasim%excite	
		
		
	end subroutine printsim


        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        !Subroutine: writePathToFile
        !Purpose: write the path of the incident particle and all secondaries
        !         to a csv file for plotting
        !Date last modified: 21/01/2021
        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        subroutine writePathToFile(simIndex,particlebasis,datasim,bmode)
            use input_data
            implicit none
             
 	    integer,intent(in):: simIndex
	    type(particle),dimension(0:1000),intent(in):: particlebasis
	    type(simdata),intent(in):: datasim
            logical,intent(in):: bmode ! True if Ps Benchmark Simulation is being done
            character(len=20)::simString, enString,xString,yString,zString,stateNumString
            character(len=20)::partNumString, timeString
            character(len=2)::inString, dissString 
            integer::ii,jj

            !Write particle path to file in order of creation. Collision event at which incident particle first
            !creates a secondary corresponds to event where first secondary in file is created.
            if (bmode) then


            else 
               write(simString,'(I0)') simIndex
               open(70, file="sim"//trim(simString)//".csv")

               write(70,*) datasim%secE+1 !Total number of electrons
               write(70,*) "type,","Incident/Second,","EnSelected,","x(m),","y(m),","z(m),","Diss,","StateNum,","partNum,","Time(s)"               
               do ii = 0, datasim%secE
                  if (ii .eq. 0) then
                     inString = "i"
                  else
                     inString = "s"
                  end if
                  inString = trim(inString)//","
  
                    
                  do jj = 0, particlebasis(ii)%colls
                     if (particlebasis(ii)%diss(jj)) then
                        dissString = "y"
                     else
                        dissString = "n"
                     end if 
                     dissString = trim(dissString)//","

                     write(enString,'(e13.5)') particlebasis(ii)%enArr(jj)
                     enString = trim(enString)//","
                     write(xString,'(e13.5)') particlebasis(ii)%x(jj)
                     xString = trim(xString)//","
                     write(yString,'(e13.5)') particlebasis(ii)%y(jj)
                     yString = trim(yString)//","
                     write(zString,'(e13.5)') particlebasis(ii)%z(jj)
                     zString = trim(zString)//","
                     write(stateNumString, '(i4)') particlebasis(ii)%state(jj)
                     stateNumString = trim(stateNumString)//","
                     write(partNumString, '(i4)') ii
                     partNumString = trim(partNumString)//","
                     write(timeString, '(e13.5)') particlebasis(ii)%time(jj)
                     timeString = trim(timeString)

                     write(70,'(a,a,a,a,a)',advance="no") adjustl("e,"),adjustl(inString),adjustl(enString),adjustl(xString),adjustl(yString)
                     write(70,'(a,a,a,a,a)') adjustl(zString),adjustl(dissString),adjustl(stateNumString),adjustl(partNumString),adjustl(timeString)
                  end do
               end do
               close(70)
            end if
        end subroutine writePathToFile 





	
	subroutine simulationresults(datamc,totalSims,en_incident,maxgen,ionop,bmode,runTime,data_input)	
                use input_data
		implicit none

                type(input),intent(in)::data_input
		type(simdata),intent(in):: datamc
		integer*8,intent(in):: totalSims
		real*8,intent(in):: en_incident
		integer,intent(in):: maxgen
		character (len=60),intent(in):: ionop ! Ionistation option
		logical,intent(in):: bmode ! True if Ps Benchmark Simulation is being done
		integer:: i
                real*8::runTime
		real*8:: aveIons,aveExcites,aveElastics, avediss ! Average number of each collision type
		real*8:: aveGens ! Average number of generations created
                real*8:: aveB1SuExc, aveC1PuExc, aveSingletExc, aveTripletExc  !Average number of different H2 excitations
		real*8,dimension(1000):: aveEperGen ! Average number of electrons per generation
		real*8,dimension(1000):: aveEnperGen ! Average number of electrons per generation
		real*8,dimension(0:1000):: avedissPerGen,aveexcPerGen,aveelPerGen,avecollPerGen ! Average number of dissociations per generation
		real*8:: fSurv ! Survival Fraction (only for Ps Benchmark Simulation)
		real*8:: aveTRes, eIon
                real*8:: wInv !1/(mean energy per ion pair)
                real*8, dimension(0:1000):: aveNumEj
                character (len=3):: enString
                !Total number of dissociations, etc over all secondary generations
                real*8:: aveIonTotal, aveDissTotal, aveExcTotal, aveRad
                real*8:: aveElTotal, aveCollTotal, aveNumTotal, aveEnTotal
                
                eIon = 15.96632 !Ionisation energy of ground state H2 (eV)	
	
                !Initialises arrays to zero
                aveEperGen(:) = 0
                aveEnperGen(:) = 0
	

                open(unit=70,file='output.txt')
		
		aveIons = float(datamc%secE)/float(totalSims)
		aveExcites = float(datamc%excite)/float(totalSims)
		aveElastics = float(datamc%elastic)/float(totalSims) 
		!aveEperGen = float(datamc%ePerGen(1))/float(totalSims)
		aveGens = float(datamc%gen)/float(totalSims)
		avediss = float(datamc%dissociations)/float(totalSims)

                aveB1SuExc = float(datamc%B1SuExc)/float(totalSims)
                aveC1PuExc = float(datamc%C1PuExc)/float(totalSims)
                aveSingletExc = float(datamc%singletExc)/float(totalSims)
                aveTripletExc = float(datamc%tripletExc)/float(totalSims)

                !Calculate mean penetration distance of incident electron
                aveRad = datamc%inERad/float(totalSims)
	
                !Calculate (1/mean energy per ion pair)
                if (en_incident .gt. eIon) then
                   wInv = aveIons/en_incident
                else
                   wInv = 0.0
                end if

	        write(70,*) 'program runtime(s)',runTime	
		write(70,*) 'inital particle energy (eV)', en_incident
		write(70,*) 'total number of simulations', totalSims
		if(bmode .eqv. .false.) then ! ionisation option only applies to default simulation
			write(70,*) 'ionisation treatment: ', ionop
		end if
		! write(70,*) 'totalIons',datamc%secE,'aveIons',aveIons
		! write(70,*) 'totalExcites',datamc%excite,'aveExcites',aveExcites
		! write(70,*) 'totalElastics',datamc%elastic,'aveElastics',aveElastics
		! write(70,*) 'totaldiss',datamc%dissociations,'avediss',avediss
		
		write(70,*) 'ave collisional ionisations',aveIons
		write(70,*) 'ave collisional excitations',aveExcites
		write(70,*) 'ave elastic collisions',aveElastics
		if(.NOT. bmode) then
			write(70,*) 'ave dissociations',avediss
		end if
		
		if(bmode) then ! Ps Formation Benchmark Run
			fSurv = 100 * (1 - float(datamc%numPsFormed)/float(totalSims))
			write(70,*) 'fSurv: ', fSurv
			write(70,*) 'datamc%numPsFormed: ', datamc%numPsFormed
			aveTRes = datamc%tRes / (float(totalSims) - float(datamc%numPsFormed))
			write(70,*) 'TRes: ', aveTRes
		else ! Default Simulation Run
			write(70,*) 'highest number of generations', maxgen
			write(70,*) 'ave number of generations', aveGens 
                        write(70,*) 'reciprocal of mean energy per ion pair:', wInv		
                        write(70,*) 'average incident particle final radius:', aveRad
                        write(70,*) 'average B1Su excitations per ion pair:', aveB1SuExc/aveIons
                        write(70,*) 'average C1Pu excitations per ion pair:', aveC1PuExc/aveIons
                        write(70,*) 'average singlet excitations per ion pair:', aveSingletExc/aveIons
                        write(70,*) 'average triplet excitations per ion pair:', aveTripletExc/aveIons
	
			do i=1,maxgen
     		                aveEperGen(i) = float(datamc%ePerGen(i)) / float(totalSims)
				aveEnperGen(i) = datamc%enPerGen(i) / float(datamc%ePerGen(i))	
			end do
			
			do i=0,maxgen
				write(70,*) '------------------------------------------------------------'
				write(70,*) 'generation:',i
				if(i .gt. 0) then					
					write(70,*) 'ave number of electrons:',aveEperGen(i)!,datamc%ePerGen(i)!,&
					write(70,*) 'ave energy of electrons (eV):',aveEnperGen(i)
				end if 
				avedissPerGen(i) = float(datamc%dissPerGen(i)) / float(totalSims)
				aveexcPerGen(i) = float(datamc%excPerGen(i)) / float(totalSims)
				aveelPerGen(i) = float(datamc%elPerGen(i)) / float(totalSims)
				avecollPerGen(i) = float(datamc%collPerGen(i)) / float(totalSims)
				write(70,*) 'ave number of ionisation collisions:',aveEperGen(i+1)				
				write(70,*) 'ave number of excitation collisions:', aveexcPerGen(i)				
				write(70,*) 'ave number of elastic collisions:', aveelPerGen(i)				
				write(70,*) 'ave number of collisions:',avecollPerGen(i)
				write(70,*) 'ave number of dissociations:', avedissPerGen(i)
			end do	 
  
                        aveNumTotal = 0.0 
                        aveEnTotal = 0.0
                        aveIonTotal = 0.0
                        aveDissTotal = 0.0
                        aveExcTotal = 0.0
                        aveElTotal = 0.0
                        aveCollTotal = 0.0

                        !Print results for secondary electrons overall 
                        do i =1,maxgen
                           aveNumTotal = aveNumTotal + aveEPerGen(i)
                           aveEnTotal = aveEnTotal + aveEnPerGen(i) 
                           aveIonTotal = aveIonTotal + aveEPerGen(i+1)
                           aveDissTotal = aveDissTotal + float(datamc%dissPerGen(i))
                           aveExcTotal = aveExcTotal + float(datamc%excPerGen(i))
                           aveElTotal = aveElTotal + float(datamc%elPerGen(i))
                           aveCollTotal = aveCollTotal + float(datamc%collPerGen(i))
                        end do	
                         

                        aveDissTotal = aveDissTotal/float(totalSims)
                        aveExcTotal = aveExcTotal/float(totalSims)
                        aveElTotal = aveElTotal/float(totalSims) 
                        aveCollTotal = aveCollTotal/float(totalSims)
                        write(70,*) '------------------------------------------------'
                        write(70,*) 'secondary total:'
                        write(70,*) 'ave number of electrons:', aveNumTotal 
                        write(70,*) 'ave energy of electrons (eV):', aveEnTotal
	                write(70,*) 'ave number of ionisation collisions:',aveIonTotal		
			write(70,*) 'ave number of excitation collisions:', aveExcTotal				
			write(70,*) 'ave number of elastic collisions:', aveElTotal		
			write(70,*) 'ave number of collisions:',aveCollTotal
			write(70,*) 'ave number of dissociations:', aveDissTotal
		end if
		
		
		!!!!!!!!!!!!!!!!!!!!!!!! NICE FORMAT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		if(.NOT. bmode) then ! Outputs only for Default Sim
			write(70,*) '------------------------------------------------'
			write(70,*) '------------------------------------------------'
			write(70,*) 'ions: total, gen0,gen1,etc'
			write(70,*) aveIons
			do i=0,maxgen-1
				write(70,*) aveEperGen(i+1)				
                        end do
            		
	
			write(70,*) 'exc: total, gen0,gen1,etc'
			write(70,*) aveExcites
			do i=0,maxgen
				write(70,*) aveexcPerGen(i)				
			end do	
			
			write(70,*) 'el: total, gen0,gen1,etc'
			write(70,*) aveElastics
			do i=0,maxgen
				write(70,*) aveelPerGen(i)			
			end do
			
			write(70,*) 'colls: gen0,gen1,etc'
			do i=0,maxgen
				write(70,*) avecollPerGen(i)			
			end do
			
			write(70,*) 'diss: total, gen0,gen1,etc'
			write(70,*) avediss
			do i=0,maxgen
				write(70,*) avedissPerGen(i)	
			end do 
			
			write(70,*) 'enpergen: gen0,gen1,etc'
			do i=0,maxgen -1
				write(70,*) aveEnperGen(i+1)
			end do
		end if
                close(70)		

                !Writes consistency check data to separate file for plotting
                if (.not. bmode) then
                   if ((ionop .eq. "SDCS") .or. (ionop .eq. "state_distribution")) then
                      aveNumEj(:) = float(datamc%numEj(:))/float(totalSims) 
                      write(enString,'(I0)') int(data_input%energyeV)
                      if (ionop .eq. 'SDCS') then
                        open(70, file = "numEjAtEnSDCS"//trim(enString)//".txt")
                      else if (ionop .eq. "state_distribution") then
                         open(70, file = "numEjAtEnDist"//trim(enString)//".txt")
                      end if
                    
                      write(70,*) "Ejection Energy (ev)           Ave Number Ejected"
                      do i = 1,1000
                         write(70,*) datamc%ejEnGrid(i), aveNumEj(i)
                      end do
                      close(70)
                   end if
                end if  

	end subroutine simulationresults	
	
	subroutine meanexcendist(statebasis)
		use totalcs_module
		use state_class
		implicit none
		type(basis_state),intent(in):: statebasis
		type(totalcs):: tcs 
		real*8:: meanexc,en_incident
		
		print*, 'creating secondary electron energy distribution (file=secEenergydist)'
		
		en_incident = 15.96632 !(eV)
		
		open(unit=90,file='secEenergydist')
		!write(90,*) 'en_incident	','meanexc	','meansecE'
		do while(en_incident .LE. 700)
			call get_csatein(statebasis,en_incident,tcs) ! Create totalcs for the current energy !call print_tcs(tcs) 
			call meanexcenergy(tcs,statebasis,meanexc)
			write(90,*) en_incident, meanexc-15.96632
			en_incident = en_incident + 0.001
		end do
		close(90)
	end subroutine meanexcendist
	
	subroutine elasticScattering(en_incident,costheta, elEnergyLoss,bmode,dcsBasis)
                use input_data 
                use dcs_module 
		implicit none
		real*8,intent(in):: en_incident	  	  ! initial energy of incident particle (eV)
		real*8,intent(out):: elEnergyLoss	  ! energy lost by incident particle (eV)
		real*8:: mParticle,mTarget 			  ! mass of particle and target (kg)
		real*8,intent(in):: costheta			  ! cosine of scattering angle (RADIANS)
		real*8:: th,randNum
		real*8:: PI, totalcsval
		logical,intent(in):: bmode
                type(basis_dcs)::dcsBasis
                type(dcs)::dcsEn
		
		PI = 4.D0*DATAN(1.D0)
		
		if(.NOT. bmode) then ! Run Default Simulation
			mParticle = 9.10938356E-31		! mass of electron (kg)
			!mParticle = 9.1093835D-31
			mTarget = 2 * 1.6726219E-27		! mass of H2 molecule (kg), assuming it is 2 * mass of proton			
	
                        if (data_in%momOp .eq. 0) then
                           !use inelastic scattering energy loss formula	
			   elEnergyLoss = (2*mParticle*mTarget)/((mParticle+mTarget)*(mParticle+mTarget))*en_incident*(1-costheta)
			   !print*, 'theta',theta*PI/180,'factor',(4*mParticle*mTarget)/((mParticle+mTarget)*(mParticle+mTarget))*(sin((theta*PI/180)/2))*(sin((theta*PI/180)/2))
		   	   !elEnergyLoss = (3.6E-4) * en_incident
                        else if (data_in%momOp .eq. 1) then
                           !Use momentum transfer cross sections to get average energy loss
                           call get_dcsatein(dcsBasis,en_incident,dcsEn,1)    !Elastic scattering is a 1->1 transition
                           elEnergyLoss = 2*((mParticle*mTarget)/(mParticle+mTarget)**2)*en_incident*dcsEn%momtcs/dcsEn%intCs
                           call delete_dcs(dcsEn) 
                        end if
		else
			! Random Number is selected between 0 and 1
			call RANDOM_NUMBER(randNum)
			th = 180.0 * randNum
			mParticle = 9.10938356E-31		! mass of positron (kg)
			!mParticle = 9.11E-31		! mass of positron (kg)
			!mTarget = 1.6735575E-27		! mass of atomic H (kg)
			mTarget = 1.6726219E-27		! mass of H atom (kg), assuming it is mass of proton
			elEnergyLoss = (4*mParticle*mTarget)/((mParticle+mTarget)*(mParticle+mTarget))*en_incident*(sin(th/2))*(sin(th/2))			
		end if
		
		
		
		!print*, 'mParticle*1E31',mParticle*1E31
		
	end subroutine elasticScattering
!
!

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !Subroutine: inelasticScattering
    !Purpose: calculates the recoil energy loss in an inelastic collision
    !Date last modified: 29/02/2020
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    subroutine inelasticScattering(en_incident, enex, costheta, energyLoss, bmode )
        real*8,intent(in):: en_incident	  	  ! initial energy of incident particle (eV)
        real*8,intent(out):: energyLoss	  ! energy lost by incident particle (eV)
	real*8:: mParticle,mTarget 			  ! mass of particle and target (kg)
	real*8,intent(in):: costheta			  ! cosine of scattering angle (RADIANS)
        logical::bmode
        real*8:: enex  !Excitation/internal energy
        real*8::en, sqrtVal

        en = en_incident

        !When generalising, masses will be input variables.
        if (bmode) then
           !Positronium benchmark mode
           mTarget = 2 * 1.6726219E-27   ! mass of H2 molecule (kg), assuming it is 2 * mass of proton			
           mParticle = 9.10938356E-31   ! mass of positron (kg)
           energyLoss = en*((2*mTarget*mParticle)/((mTarget+mParticle)**2) + &
                            enex/(en*(1+(mParticle/mTarget))) - &
                            (2*mParticle*costheta/(mParticle+mTarget))*sqrt((mTarget/(mTarget+mParticle))**2 &
                            - enex/(en*(1+mParticle/mTarget))))
        else
           !Default simulation 
           mTarget = 2 * 1.6726219E-27   ! mass of H2 molecule (kg), assuming it is 2 * mass of proton			
           mParticle = 9.10938356E-31   ! mass of electron (kg) 
           sqrtVal =  (mTarget/(mTarget+mParticle))**2 - enex/(en*(1.0+mParticle/mTarget))
           if (sqrtVal .gt. 0.0) then
              energyLoss = en*((2.0*mTarget*mParticle)/((mTarget+mParticle)**2) + &
                            enex/(en*(1.0+(mParticle/mTarget))) - &
                            (2.0*mParticle*costheta/(mParticle+mTarget))*sqrt((mTarget/(mTarget+mParticle))**2 &
                            - enex/(en*(1.0+mParticle/mTarget)))) 
           else
              print*, "SQRTVAL: ", sqrtVal
              print*, "ENEX, EIN: ", enex, en
              print*, "ERROR: ratio excitationEn/eIncident .gt. 1/(1+mParticle/mTarget), stopping"
              stop
           end if
        end if
    end subroutine inelasticScattering








 subroutine selectstate(tcs,part,coll,stateNum)
     use input_data
     use totalcs_module 
	
     implicit none 
     integer, intent(in):: coll
     type(totalcs), intent(in):: tcs
     type(particle), intent(inout):: part ! The current particle
     integer,intent(out):: stateNum
     real*8, dimension(:),allocatable:: stateprob
     real*8:: randNum, sigma, den 
     integer:: i

     !Density of the medium, set in input file.	
     !den = data_in%density 

     allocate(stateprob(tcs%Nmax))

     ! stateprob is cumulative probabilty for each state
     call normalisetcs(tcs,stateprob,tcs%Nmax)
	
     ! Random Number is selected between 0 and 1
     call RANDOM_NUMBER(randNum)
	
     ! Determines which state (the 'i'th process in the array) is selected
     i = 1
     do while (stateprob(i) .le. randNum)
        i = i + 1		
     end do    

     ! Ensures that the state is valid
     ! Due to numerical accuracy,stateprob(tcs%Nmax) may be less than 1.0
     if(i .lt. tcs%Nmax) then
        stateNum = i
     else
        stateNum = tcs%Nmax
     end if

     part%state(coll) = stateNum ! records the state chosen at this collision for this particle
     if (tcs%en(i) .gt. 0.0) then
        !print*, tcs%en(i) 
     end if	


     !print*, 'randNum',randNum
     ! ! Be careful printing this next line if stateNum=1
     if(stateNum .eq. 1) then
     !print*,'stateprob(stateNum)',stateprob(stateNum)
     else
     !print*,'stateprob(stateNum)',stateprob(stateNum),'stateprob(stateNum-1)',stateprob(stateNum-1)
     end if
     !print*, 'stateNum =',stateNum

     !Convert cross section to SI units, density in 1/m^3
     !sigma = tcs%CS(stateNum)*(data_in%bohrRadius)**2 
     !part%path(coll) = 1.0/(den*sigma)

     !asdfsdfs !Write function to sample path length at given energy
     deallocate(stateprob) !deallocate variable allocated in 'normalisetcs' 
	
  end subroutine selectstate




! subroutine selectVcsState(vcsIn,part,coll,enex,stateBasis,minExcEn)
!     use totalcs_module 
!     use state_class	

!     implicit none 
!     integer, intent(in):: coll
!     type(vcs), intent(in):: vcsIn
!     type(totalcs)::tcsOb
!     type(basis_state)::stateBasis
!     type(particle), intent(inout):: part ! The current particle
!     integer:: stateNum
!     real*8, dimension(:),allocatable:: stateprob
!     real*8:: randNum, sigma, den, minExcEn
!     real*8, intent(out)::enex
!     integer:: i
	
!     den = 1 !To be replaced with Danny's suggested number density

     ! stateprob is cumulative probabilty for each state
!     call normaliseVcs(vcsIn,stateprob)
	
     ! Random Number is selected between 0 and 1
!     call RANDOM_NUMBER(randNum)
	
     ! Determines which state (the 'i'th process in the array) is selected
!     i = 1
!     if (sum(stateprob) .gt. 0.0) then
        !Probability is non-zero
!        do while (stateprob(i) .le. randNum)
!           i = i + 1		
!        end do    
!     else 
!        i=1 !Stays in ground state
!     end if
	
     ! Ensures that the state is valid
     ! Due to numerical accuracy,stateprob(vcsBasis%numVcs) may be less than 1.0
!     if(i .lt. vcsIn%nvf) then
!        stateNum = i
!     else
!        stateNum = vcsIn%nvf
!     end if

!     if(i .gt. 1) then
!        sigma = vcsIn%cs(stateNum)
!     else
!        !Need a physically reasonable choice for sigma. Below is included to 
        !get vcs running.
 
        !Use elastic scattering CS in case of vf = 0
!        if (sum(stateprob) .gt. 0.0) then 
!           sigma = vcsIn%cs(i)
!        else
!           call get_csatein(stateBasis,minExcEn,tcsOb)
!           sigma = tcsOb%cs(1)
!           call delete_totalcs(tcsOb)
!        end if            
!     end if

     !part%path(coll) = 1.0/(den*sigma)
 !    enex = vcsIn%en(stateNum)

  !   deallocate(stateprob) !deallocate variable allocated in 'normaliseVcs' 
	
!  end subroutine selectVcsState




   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   !Subroutine: selectPath
   !Purpose: selects path length from TCS at given energy.
   !Date last modified: 29/01/2021
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   subroutine selectPath(path,stateBasis,eIncident,coll)
       use state_class
       use totalcs_module
       use input_data
       implicit none
       real*8::eIncident, randVal, sigma
       real*8,intent(out):: path
       type(basis_state)::stateBasis
       type(totalcs)::tcs
       integer::coll

       randVal = 0.0

       !Get total cross section at given energy.
       call get_csatein(stateBasis,eIncident,tcs)
       sigma = SUM(tcs%cs)*(data_in%bohrRadius**2)  !Convert to SI

       !Draw path length from exponential distribution
       if(data_in%radop .eq. 1) then
          call RANDOM_NUMBER(randVal)
          if (.not.(randVal .gt. 0.0)) then
             do while (.not.(randVal .gt. 0.0))
                call RANDOM_NUMBER(randVal)
             end do
          end if
          path = (-1.0)*(1/(data_in%density*sigma))*log(randVal)
       else if (data_in%radop .eq. 0) then
          path = 1/(data_in%density*sigma) 
       end if
       
       call delete_totalcs(tcs)
 
   end subroutine selectPath















  
  SUBROUTINE timeElapsed(energy,stateNum,crossSection,VarPs,datasim)

	use Ps_module
	
	IMPLICIT NONE
	REAL, INTENT(IN) :: energy
	INTEGER, INTENT(IN) :: stateNum
	type(PsVar), intent(in) :: VarPs
	REAL*8 :: m_p, eVToJoules, velocity, constant, con2, m
	real*8, intent(in) :: crossSection
	!REAL*8, INTENT(OUT) :: duration
	type(simdata),intent(inout):: datasim
	
	m_p = 	9.109E-31 
	m = 9.1093897
	
	m_p = 9.10938356E-31 ! mass of positron
	
	eVToJoules = 1.60218E-19
	
	
		
	! IF(stateNum .EQ. 4) THEN
		! crossSection = VarPs%cs_Ps
	! ELSE IF(stateNum .EQ. 1) THEN
		! crossSection = VarPs%cs_el
	! ELSE IF(stateNum .EQ. 3) THEN
		! crossSection = VarPs%cs_ion
	! ELSE IF(stateNum .EQ. 2) THEN
		! crossSection = VarPs%cs_exc
	! ELSE 
		! !crossSection = 0.0
	! END IF
	
	! Convert Cross section from A^2 to m^2
	!crossSection = crossSection * 10**(-20)
	
	! constant is equal to eVToJoules/m_p
	constant = 1.7565E11
	
	con2 = 1!*10**(14)
	
	!velocity = (2 * energy * eVToJoules / m_p) ** (0.5)
	
	!duration = 1 / (crossSection * velocity)	
	
	!duration = ((m_p)**(1/2)) / (crossSection * ((2 * energy * eVToJoules)**(1/2)))
	!duration = ((m_p)**(1/2)) / (((2 * energy * eVToJoules)**(1/2)))
	
	!duration = (m**0.5)/((2*energy * 1.60218)**(0.5) * crossSection) / 10 ! in terms of s*m^-3 * 10^15
	!duration = ((m/(2*energy*1.60218))**(0.5))/(crossSection*10*3.2) ! in terms of s*m^-3 * 10^15
	
	! THis is what I had before the update
	!velocity = (2 * energy * constant) ** (0.5)
	!duration = ((m/(2*energy*1.602176565))**(0.5))/(crossSection*10) ! in terms of s*m^-3 * 10^15
	
	
	
	! Update 03/07/2019 !
	
	datasim%duration = 10E15 * sqrt(m_p / (2*energy*eVToJoules)) * 10E20 / crossSection ! puts it into 10^15 form?
	datasim%duration = sqrt(m_p / (2*energy*eVToJoules)) * 10E20 / crossSection ! unaltered
	datasim%duration = 10E-15 * sqrt(m_p / (2*energy*eVToJoules)) * 10E20 / crossSection ! altered?
	!print*, 'duration', datasim%duration
	
	!write(2,*) 'vel', velocity, 'cs', crossSection, 'energy', energy, 'duration', duration
	
  END SUBROUTINE timeElapsed


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !Subroutine: selectAngle
  !Purpose: selects a scattering angle (cos(theta)) from cross sections
  !         differential in solid angle (dcs)
  !Date last modified: 06/07/2020
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  SUBROUTINE selectAngle(eldcs,eIncident,costheta)
     use dcs_module
     implicit none
     type(basis_dcs), intent(in)::eldcs
     real*8, intent(in)::eIncident 
     real*8, intent(out)::costheta 
     type(dcs)::dcsBelow, dcsAbove
     integer::ii, numPoints, indexVal
     real*8::total, thetaK, randNum
     real*8, allocatable, dimension(:)::sums !array of partial sums 
     real*8, allocatable, dimension(:)::dcsArray !array of dcs at incident energy
     real*8::intp1, intp2, intp3 !Used to break up long interpolation formula

     !Finds dcs for above and below given incident energy
     ii =1
     do while( (ii .le. eldcs%Ndcs) .and. (eldcs%ein(ii) .lt. eIncident) )
        ii = ii +1
     end do
     call copyDcs(dcsBelow,eldcs%dcsbasis(ii-1))
     call copyDcs(dcsAbove,eldcs%dcsbasis(ii))
     !!dcsBelow = eldcs%dcsbasis(ii-1)    
     !!dcsAbove = eldcs%dcsbasis(ii)

     allocate(sums(dcsBelow%Nth), dcsArray(dcsBelow%Nth))
   
     do ii = 1, dcsBelow%Nth
        !Interpolates to find cross sections at given energy.
        intp1 = (eIncident-dcsBelow%en_incident)
        intp2 = (dcsAbove%dcs(ii)-dcsBelow%dcs(ii))
        intp3 = (dcsAbove%en_incident-dcsBelow%en_incident)
        dcsArray(ii) = dcsBelow%dcs(ii) + intp1*(intp2/intp3)
     end do

     !Computes total cross section
     call getSum(dcsArray, dcsBelow%Nth, total) 

     !Constructs distribution.      
     sums = 0.d0 !Initialises array
     numPoints = dcsBelow%Nth !Number of cross sections, also num angle points
     sums(1) = (dcsArray(1)/total)
     do ii = 2, numPoints
        sums(ii) = sums(ii-1) + (dcsArray(ii)/total)
        !print*, "SUM, ANGLE: ", sums(ii), dcsBelow%theta(ii)
     end do
     !sums(:) = sums(:)*abs(sin(dcsBelow%theta(:)))

     !Generates random number
     call RANDOM_NUMBER(randNum)
     ii = 1          
     do while (sums(ii) .lt. randNum)
        ii = ii + 1
     end do

     !Selected angle
     costheta = cos(dcsBelow%theta(ii)) 

     call delete_dcs(dcsBelow)
     call delete_dcs(dcsAbove)
     deallocate(sums, dcsArray)

  END SUBROUTINE selectAngle



 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !Subroutine: getSum
 !Purpose: sums over differential cross sections in imported array
 !Date last modified: 27/03/2020
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 subroutine getSum(dcsArrIn, Ndcs, total)
    implicit none
    real*8, dimension(:), intent(in)::dcsArrIn
    real*8::total
    integer::ii, Ndcs

    !Sums differential cross sections
    total = 0
    do ii = 1, Ndcs
       total = total + dcsArrIn(ii)
    end do

 end subroutine getSum






 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !Subroutine: selectEjEn
 !Purpose: selects an ejection energy for secondary
 !         electrons from sdcs, defined over 2D
 !         fine energy grid.
 !Date last modified: 06/05/2020
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 subroutine selectEjEn(sdcsAtEIn, ejEn)
    use sdcs_module
    implicit none
    type(sdcs)::sdcsAtEIn
    real*8::ejEn !Selected ejection energy
    real*8, allocatable, dimension(:)::enProb
    real*8::randNum !Uniform random number
    integer::enNum, ii

    allocate(enProb(sdcsAtEIn%Ncgsdcs))    

    !Construct cumulative distribution
    call normalisesdcs(sdcsAtEIn, enProb, sdcsAtEIn%Ncgsdcs)

    !Select energy
    call RANDOM_NUMBER(randNum)

    !Find selected state
    ii = 1
    do while (enProb(ii) .lt. randNum)
       ii = ii +1
    end do

    !Account for rare case when eIncident -eIon < deltaE, where deltaE is the
    !grid step size. 
    if (int(enProb(1)) .eq. 2) then
       !Normalisesdcs sets enProb(1) to 2 when this occurs       
       ejEn = sdcsAtEIn%ecg(2) - sdcsAtEIn%ecg(1) !Ensures no further events can occur. 
    else
       !Check validity
       if (ii .lt. sdcsAtEIn%Ncgsdcs) then
          enNum = ii
       else
          enNum = sdcsAtEIn%Ncgsdcs
       end if
       ejEn = sdcsAtEIn%ecg(enNum)
    end if 
    deallocate(enProb) 
 end subroutine selectEjEn






   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   !subroutine: lossFunction
   !Purpose: calculates and returns the energy loss distribution
   !         function L(E) used in the continuous slowing down
   !         approximation. Used to check validity of interpolated
   !         cross sections.
   !Date last modified: 19/03/2021
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   subroutine lossFunction(statebasis, eldcs, sdcsBasis, data_input, enfine, Nenfine, lossFunc, lossFuncLen)
       use state_class        ! defines states (and basis of them) with operations on them
       use totalcs_module     !  reading totalcs files
       use sdcs_module
       use input_data			! contains input such as incident energy, benchmark mode
       use dcs_module         ! deals with elastic DCS
       implicit none
       
       type(input), intent(in):: data_input
       type(basis_state),intent(in):: statebasis
       type(basis_dcs),intent(in):: eldcs    ! keep elastic DCS here
       type(basis_sdcs)::sdcsBasis
       real*8, dimension(:), allocatable:: enfine
       integer:: Nenfine, ii, jj
       integer, intent(out):: lossFuncLen
       real*8, dimension(:), allocatable:: lossFunc 
       !real*8, dimension(:), allocatable:: sigmaSp
       real*8:: massProj
       real*8:: massTarget 
       type(totalcs)::tcs
       type(dcs)::dcsEn
       type(sdcs)::sdcsEn
       real*8:: eIncident, eIon, intValTop, intValBot
       real*8:: enCurr, sigmaMt, elCollLoss
       real*8:: excEnSum, sdcsInt, cutoffEn 

       !sigmaSp is the stopping power cross section defined in 
       !Fursa, Zammit, et al. 2017- Electron mass stopping power in H2.
       !allocate(sigmaSp(Nenfine))

       !Definition for lossFunc = L(E) taken from: Dalgarno, Yan and Liu,
       !1999 - Electron energy deposition in a gas mxture of atomica and 
       !molecuar hydrogen and helium. Eqn 3.
       if (allocated(lossFunc)) then
          deallocate(lossFunc)
       end if

       allocate(lossFunc(Nenfine-1))
       lossFuncLen = Nenfine-1

       massProj = 9.11e-31  !Electron mass
       massTarget = (2.0)*1.6726219E-27      !Mass of H2
       eIon = 15.96632 !Ionisation energy of ground state H2 (eV)	

       do ii = 1, Nenfine-1
          eIncident = enfine(ii)
          if (eIncident .gt. statebasis%b(2)%enex) then
             !print*, eIncident
             call get_csatein(statebasis,eIncident, tcs)
             call get_dcsatein(eldcs, eIncident, dcsEn,1) 
             call get_sdcsatein(sdcsBasis, eIncident,sdcsEn) 
 
             sigmaMt = dcsEn%momtcs              !Momentum transfer CS
             !Sum over cross section weighted bound excitation energies
             excEnSum = 0.0
             jj = 1
             do while((tcs%en(jj+1) .lt. 0.0) .and. (jj .lt. tcs%Nmax-1)) 
                excEnSum = excEnSum + tcs%cs(jj+1)*abs(tcs%en(jj+1)-tcs%en(1))*data_input%eV
                jj = jj+1
             end do
             !excEnSum = excEnSum + tcs%cs(jj+1)*abs(tcs%en(jj+1)-tcs%en(1))*data_input%eV

             !Term used by dalgarno to model energy loss in elastic collisions
             !of fast electrons with ambient electrons.
             !ne =     !Fast electron number density
             !vEl = sqrt(2*eIncident/massProj)  !Fast electron velocity
             !Ee = 8.62e-3  !Value used by dalgarno
             !elCollLoss = ((2.0*1e-4)*(ne**0.97)/(eIncident)**0.44)*((eIncident-Ee)/(eIncident-0.53*Ee))**2.36       !Set to zero for initial testing
             !elCollLoss = elCollLoss/(data_input%density*vEl)
             elCollLoss = 0.0

             !Integrate over SDCS.
             sdcsInt = 0.0
             jj = 1
             cutoffEn = (eIncident -eIon)/2.0
             enCurr = sdcsEn%ecg(jj)
             do while((enCurr .le. cutoffEn) .and. (jj .le. sdcsEn%Ncgsdcs-1))
                !Use trapezoidal integration rule
                intValTop = (eIon + sdcsEn%ecg(jj+1))*sdcsEn%CS(jj+1)
                intValBot = (eIon + sdcsEn%ecg(jj))*sdcsEn%CS(jj)
                sdcsInt = sdcsInt + ((intValTop + intValBot)/2.0)*(sdcsEn%ecg(jj+1)-sdcsEn%ecg(jj))

                jj = jj+1
                enCurr = sdcsEn%ecg(jj)
             end do
 
             lossFunc(ii) = 2*(massProj*eIncident/massTarget)*sigmaMt + elCollLoss + excEnSum + sdcsInt 
             lossFunc(ii) = lossFunc(ii)*(data_input%bohrRadius*100)**2  !Print result in cm^2*eV
          end if
       end do 

   end subroutine lossFunction






   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   !subroutine: lossFunctionPseudo
   !Purpose: calculates and returns the energy loss distribution
   !         function L(E) used in the continuous slowing down
   !         approximation. Used to check validity of interpolated
   !         cross sections. Uses pseudostates in stead of SDCS.
   !Date last modified: 21/03/2021
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   subroutine lossFunctionPseudo(statebasis, eldcs, sdcsBasis, data_input, enfine, Nenfine, lossFunc, lossFuncLen)
       use state_class        ! defines states (and basis of them) with operations on them
       use totalcs_module     !  reading totalcs files
       use sdcs_module
       use input_data			! contains input such as incident energy, benchmark mode
       use dcs_module         ! deals with elastic DCS
       implicit none
       
       type(input), intent(in):: data_input
       type(basis_state),intent(in):: statebasis
       type(basis_dcs),intent(in):: eldcs    ! keep elastic DCS here
       type(basis_sdcs)::sdcsBasis
       real*8, dimension(:), allocatable:: enfine
       integer:: Nenfine, ii, jj
       integer, intent(out):: lossFuncLen
       real*8, dimension(:), allocatable:: lossFunc 
       !real*8, dimension(:), allocatable:: sigmaSp
       real*8:: massProj
       real*8:: massTarget 
       type(totalcs)::tcs
       type(dcs)::dcsEn
       !type(sdcs)::sdcsEn
       real*8:: eIncident, eIon, intValTop, intValBot
       real*8:: enCurr, sigmaMt, elCollLoss
       real*8:: excEnSum, sdcsInt, cutoffEn 

       !sigmaSp is the stopping power cross section defined in 
       !Fursa, Zammit, et al. 2017- Electron mass stopping power in H2.
       !allocate(sigmaSp(Nenfine))

       !Definition for lossFunc = L(E) taken from: Dalgarno, Yan and Liu,
       !1999 - Electron energy deposition in a gas mxture of atomica and 
       !molecuar hydrogen and helium. Eqn 3.
       if (allocated(lossFunc)) then
          deallocate(lossFunc)
       end if
       allocate(lossFunc(Nenfine-1))
       lossFuncLen = Nenfine-1

       massProj = 9.11e-31  !Electron mass
       massTarget = (2.0)*1.6726219E-27      !Mass of H2
       eIon = 15.96632 !Ionisation energy of ground state H2 (eV)	

       do ii = 1, Nenfine-1
          eIncident = enfine(ii)
          if (eIncident .gt. statebasis%b(2)%enex) then
             !print*, eIncident
             call get_csatein(statebasis,eIncident, tcs)
             call get_dcsatein(eldcs, eIncident, dcsEn,1) 
             !call get_sdcsatein(sdcsBasis, eIncident,sdcsEn) 
 
             sigmaMt = dcsEn%momtcs              !Momentum transfer CS
             !Sum over cross section weighted bound excitation energies
             excEnSum = 0.0
             jj = 1
             do while(jj .lt. tcs%Nmax-1)
                excEnSum = excEnSum + tcs%cs(jj+1)*abs(tcs%en(jj+1)-tcs%en(1))*data_input%eV
                jj = jj+1
             end do
             excEnSum = excEnSum + tcs%cs(jj+1)*abs(tcs%en(jj+1)-tcs%en(1))*data_input%eV

             !Term used by dalgarno to model energy loss in elastic collisions
             !of fast electrons with ambient electrons.
             !ne =     !Fast electron number density
             !vEl = sqrt(2*eIncident/massProj)  !Fast electron velocity
             !Ee = 8.62e-3  !Value used by dalgarno
             !elCollLoss = ((2.0*1e-4)*(ne**0.97)/(eIncident)**0.44)*((eIncident-Ee)/(eIncident-0.53*Ee))**2.36       !Set to zero for initial testing
             !elCollLoss = elCollLoss/(data_input%density*vEl)
             elCollLoss = 0.0

             !Integrate over SDCS.
             !sdcsInt = 0.0
             !jj = 1
             !cutoffEn = (eIncident -eIon)/2.0
             !enCurr = sdcsEn%ecg(jj)
             !do while((enCurr .le. cutoffEn) .and. (jj .le. sdcsEn%Ncgsdcs-1))
                !Use trapezoidal integration rule
             !   intValTop = (eIon + sdcsEn%ecg(jj+1))*sdcsEn%CS(jj+1)
             !   intValBot = (eIon + sdcsEn%ecg(jj))*sdcsEn%CS(jj)
             !   sdcsInt = sdcsInt + ((intValTop + intValBot)/2.0)*(sdcsEn%ecg(jj+1)-sdcsEn%ecg(jj))

             !   jj = jj+1
             !   enCurr = sdcsEn%ecg(jj)
             !end do
 
             lossFunc(ii) = 2*(massProj*eIncident/massTarget)*sigmaMt + elCollLoss + excEnSum 
             lossFunc(ii) = lossFunc(ii)*(data_input%bohrRadius*100)**2  !Print result in cm^2*eV
          end if
       end do 

   end subroutine lossFunctionPseudo





   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   !subroutine: lossFunctionSplit
   !Purpose: calculates and returns the energy loss distribution
   !         function L(E) used in the continuous slowing down
   !         approximation. Returns bound excitation part and 
   !         continuum part. Used to check validity of interpolated
   !         cross sections. Uses SDCS.
   !Date last modified: 24/03/2021
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   subroutine lossFunctionSplit(statebasis, eldcs, sdcsBasis, data_input, enfine, Nenfine, lossFuncBound, lossFuncIon, lossFuncLen)
       use state_class        ! defines states (and basis of them) with operations on them
       use totalcs_module     !  reading totalcs files
       use sdcs_module
       use input_data			! contains input such as incident energy, benchmark mode
       use dcs_module         ! deals with elastic DCS
       implicit none
       
       type(input), intent(in):: data_input
       type(basis_state),intent(in):: statebasis
       type(basis_dcs),intent(in):: eldcs    ! keep elastic DCS here
       type(basis_sdcs)::sdcsBasis
       real*8, dimension(:), allocatable:: enfine
       integer:: Nenfine, ii, jj
       integer, intent(out):: lossFuncLen
       real*8, dimension(:), allocatable:: lossFuncBound, lossFuncIon 
       !real*8, dimension(:), allocatable:: sigmaSp
       real*8:: massProj
       real*8:: massTarget 
       type(totalcs)::tcs
       type(dcs)::dcsEn
       type(sdcs)::sdcsEn
       real*8:: eIncident, eIon, intValTop, intValBot
       real*8:: enCurr, sigmaMt, elCollLoss
       real*8:: excEnSum, sdcsInt, cutoffEn 

       !sigmaSp is the stopping power cross section defined in 
       !Fursa, Zammit, et al. 2017- Electron mass stopping power in H2.
       !allocate(sigmaSp(Nenfine))

       !Definition for lossFunc = L(E) taken from: Dalgarno, Yan and Liu,
       !1999 - Electron energy deposition in a gas mxture of atomica and 
       !molecuar hydrogen and helium. Eqn 3.
       if (allocated(lossFuncBound)) then
          deallocate(lossFuncBound)
       end if
       if (allocated(lossFuncIon)) then
          deallocate(lossFuncIon)
       end if

       allocate(lossFuncBound(Nenfine-1), lossFuncIon(Nenfine-1))
       lossFuncLen = Nenfine-1

       massProj = 9.11e-31  !Electron mass
       massTarget = (2.0)*1.6726219E-27      !Mass of H2
       eIon = 15.96632 !Ionisation energy of ground state H2 (eV)	

       do ii = 1, Nenfine-1
          eIncident = enfine(ii)
          if (eIncident .gt. statebasis%b(2)%enex) then
             !print*, eIncident
             call get_csatein(statebasis,eIncident, tcs)
             call get_dcsatein(eldcs, eIncident, dcsEn,1) 
             call get_sdcsatein(sdcsBasis, eIncident,sdcsEn) 
 
             sigmaMt = dcsEn%momtcs              !Momentum transfer CS
             !Sum over cross section weighted bound excitation energies
             excEnSum = 0.0
             jj = 1
             do while((tcs%en(jj+1) .lt. 0.0) .and. (jj .lt. tcs%Nmax-1))
                excEnSum = excEnSum + tcs%cs(jj+1)*abs(tcs%en(jj+1)-tcs%en(1))*data_input%eV
                jj = jj+1
             end do
             !excEnSum = excEnSum + tcs%cs(jj+1)*abs(tcs%en(jj+1)-tcs%en(1))*data_input%eV

             !Term used by dalgarno to model energy loss in elastic collisions
             !of fast electrons with ambient electrons.
             !ne =     !Fast electron number density
             !vEl = sqrt(2*eIncident/massProj)  !Fast electron velocity
             !Ee = 8.62e-3  !Value used by dalgarno
             !elCollLoss = ((2.0*1e-4)*(ne**0.97)/(eIncident)**0.44)*((eIncident-Ee)/(eIncident-0.53*Ee))**2.36       !Set to zero for initial testing
             !elCollLoss = elCollLoss/(data_input%density*vEl)
             elCollLoss = 0.0

             !Integrate over SDCS.
             sdcsInt = 0.0
             jj = 1
             cutoffEn = (eIncident -eIon)/2.0
             enCurr = sdcsEn%ecg(jj)
             do while((enCurr .le. cutoffEn) .and. (jj .le. sdcsEn%Ncgsdcs-1))
                !Use trapezoidal integration rule
                intValTop = (eIon + sdcsEn%ecg(jj+1))*sdcsEn%CS(jj+1)
                intValBot = (eIon + sdcsEn%ecg(jj))*sdcsEn%CS(jj)
                sdcsInt = sdcsInt + ((intValTop + intValBot)/2.0)*(sdcsEn%ecg(jj+1)-sdcsEn%ecg(jj))

                jj = jj+1
                enCurr = sdcsEn%ecg(jj)
             end do
 
             lossFuncBound(ii) = excEnSum 
             lossFuncBound(ii) = lossFuncBound(ii)*(data_input%bohrRadius*100)**2  !Print result in cm^2*eV
             lossFuncIon(ii) = sdcsInt
             lossFuncIon(ii) = lossFuncIon(ii)*(data_input%bohrRadius*100)**2  !Print result in cm^2*eV
          end if
       end do 

   end subroutine lossFunctionSplit




   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   !subroutine: lossFunctionSplitPseudo
   !Purpose: calculates and returns the energy loss distribution
   !         function L(E) used in the continuous slowing down
   !         approximation. Returns bound excitation part and 
   !         continuum part. Used to check validity of interpolated
   !         cross sections. Uses pseudostates in stead of SDCS.
   !Date last modified: 24/03/2021
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   subroutine lossFunctionSplitPseudo(statebasis, eldcs, sdcsBasis, data_input, enfine, Nenfine, lossFuncBound, lossFuncIon, lossFuncLen)
       use state_class        ! defines states (and basis of them) with operations on them
       use totalcs_module     !  reading totalcs files
       use sdcs_module
       use input_data			! contains input such as incident energy, benchmark mode
       use dcs_module         ! deals with elastic DCS
       implicit none
       
       type(input), intent(in):: data_input
       type(basis_state),intent(in):: statebasis
       type(basis_dcs),intent(in):: eldcs    ! keep elastic DCS here
       type(basis_sdcs)::sdcsBasis
       real*8, dimension(:), allocatable:: enfine
       integer:: Nenfine, ii, jj
       integer, intent(out):: lossFuncLen
       real*8, dimension(:), allocatable:: lossFuncBound, lossFuncIon 
       !real*8, dimension(:), allocatable:: sigmaSp
       real*8:: massProj
       real*8:: massTarget 
       type(totalcs)::tcs
       type(dcs)::dcsEn
       type(sdcs)::sdcsEn
       real*8:: eIncident, eIon, intValTop, intValBot
       real*8:: enCurr, sigmaMt, elCollLoss
       real*8:: excEnSum, sdcsInt, cutoffEn 

       !sigmaSp is the stopping power cross section defined in 
       !Fursa, Zammit, et al. 2017- Electron mass stopping power in H2.
       !allocate(sigmaSp(Nenfine))

       !Definition for lossFunc = L(E) taken from: Dalgarno, Yan and Liu,
       !1999 - Electron energy deposition in a gas mxture of atomica and 
       !molecuar hydrogen and helium. Eqn 3.
       if (allocated(lossFuncBound)) then
          deallocate(lossFuncBound)
       end if
       if (allocated(lossFuncIon)) then
          deallocate(lossFuncIon)
       end if


       allocate(lossFuncBound(Nenfine-1), lossFuncIon(Nenfine-1))
       lossFuncLen = Nenfine-1

       massProj = 9.11e-31  !Electron mass
       massTarget = (2.0)*1.6726219E-27      !Mass of H2
       eIon = 15.96632 !Ionisation energy of ground state H2 (eV)	

       do ii = 1, Nenfine-1
          eIncident = enfine(ii)
          if (eIncident .gt. statebasis%b(2)%enex) then
             !print*, eIncident
             call get_csatein(statebasis,eIncident, tcs)
             call get_dcsatein(eldcs, eIncident, dcsEn,1) 
             call get_sdcsatein(sdcsBasis, eIncident,sdcsEn) 
 
             sigmaMt = dcsEn%momtcs              !Momentum transfer CS
             !Sum over cross section weighted bound excitation energies
             excEnSum = 0.0
             jj = 1
             do while((tcs%en(jj+1) .lt. 0.0) .and. (jj .lt. tcs%Nmax-1))
                excEnSum = excEnSum + tcs%cs(jj+1)*abs(tcs%en(jj+1)-tcs%en(1))*data_input%eV
                jj = jj+1
             end do
             !excEnSum = excEnSum + tcs%cs(jj+1)*abs(tcs%en(jj+1)-tcs%en(1))*data_input%eV

             !Term used by dalgarno to model energy loss in elastic collisions
             !of fast electrons with ambient electrons.
             !ne =     !Fast electron number density
             !vEl = sqrt(2*eIncident/massProj)  !Fast electron velocity
             !Ee = 8.62e-3  !Value used by dalgarno
             !elCollLoss = ((2.0*1e-4)*(ne**0.97)/(eIncident)**0.44)*((eIncident-Ee)/(eIncident-0.53*Ee))**2.36       !Set to zero for initial testing
             !elCollLoss = elCollLoss/(data_input%density*vEl)

             elCollLoss = 0.0

             lossFuncBound(ii) = excEnSum 
             lossFuncBound(ii) = lossFuncBound(ii)*(data_input%bohrRadius*100)**2  !Print result in cm^2*eV

             excEnSum = 0.0
             if (jj .lt. tcs%Nmax-1) then
                do while((tcs%en(jj+1) .gt. 0.0) .and. (jj .lt. tcs%Nmax-1))
                   excEnSum = excEnSum + tcs%cs(jj+1)*abs((tcs%en(jj+1)-tcs%en(1)))*data_input%eV
                   jj = jj+1
                end do
                excEnSum = excEnSum + tcs%cs(jj+1)*abs(tcs%en(jj+1)-tcs%en(1))*data_input%eV
             end if

             lossFuncIon(ii) = excEnSum
             lossFuncIon(ii) = lossFuncIon(ii)*(data_input%bohrRadius*100)**2  !Print result in cm^2*eV
          end if
       end do 

   end subroutine lossFunctionSplitPseudo




    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !Subroutine: sampleNormal
    !Purpose: samples normal probability distribution with given mean 
    !         mu and standard deviation sigma
    !Date last modified: 14/06/2021
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    subroutine sampleNormal(xToGet, mu, sigma)
        implicit none
        real*8, intent(inout):: xToGet
        real*8:: mu, sigma   !Mean and standard deviation
        real*8, dimension(:), allocatable:: xVec, weights, PVec, func
        real*8:: dx, randVal
        integer:: ii, kk, numX
        integer:: istart, istop 
        logical:: found
  
        dx = 0.1
        !x domain will be from -5*sigma to 5*sigma
        numX = int(10.0d0*sigma/dx) +1
        allocate(xVec(numX))
        xVec(1) = -5.0d0*sigma
        do ii =2, numX
           xVec(ii) = xVec(ii-1) + dx
        end do
 
        allocate(PVec(numX), func(numX))

        PVec(:) = 0.0d0
        func(:) = 0.0d0
        !Use composite integration rule to form cumulative probability distribution
        func(:) = (1.0d0/(sqrt(2.0d0*4.0d0*atan(1.0d0))*sigma))*exp(-(xVec(:)-mu)**2/(2.0d0*sigma**2))
        istart = 1 
        istop = numX+1
        PVec(1) = 0.0d0    !P(-infinity) = 0, cumulative distribution over the reals
        do ii=istart+2, istop-2,2
           !even points: Simpson 3/8 rule:
           PVec(ii+1)=PVec(ii-2)+(func(ii-2)+3.0d0*func(ii-1)+3.0d0*func(ii)+func(ii+1))*0.375d0*dx
           !odd points: Simpson 1/3 rule:
           PVec(ii)=PVec(ii-2)+(func(ii-2)+4.0d0*func(ii-1)+func(ii))*dx/3.0d0
        enddo
 
        call random_number(randVal)
 
        found = .false.
        ii = 1
        do while( .not. found) 
           if (PVec(ii) .ge. randVal) then
              found = .true.
              xToGet = xVec(ii)
           end if
           ii = ii+1
        end do

        if (.not. found) then
           print*, "ERROR: value not selected from normal distribution. Check function 'sampleNormal' in monteCarlo.f90"
           stop
        end if
        deallocate(xVec)
    end subroutine sampleNormal



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !Subroutine: calculateErrors
    !Purpose: calculates the errors and other useful values and prints
    !         them to a file. 
    !Date last modified: 15/06/2021
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    subroutine calculateErrors(datamcArray, numVars, data_input)
        use input_data
        implicit none
        integer:: numVars   !Number of variations of the input parameters
        type(input)::data_input
        type(simdata), dimension(numVars):: datamcArray
        integer:: numSimsVal, ii
        !Mean values of the outputs of each run of the simulation
        real*8:: mObIons, mObExcites, mObElastics, mObGens, mObDiss, mObB1SuExc, mObC1PuExc
        real*8:: mObSingletExc, mObTripletExc, mObRad
        real*8:: mObSingletPerIonPair, mObTripletPerIonPair 
        real*8:: mObB1SuIonPair, mObC1PuIonPair
        real*8:: mObW
        !Mean squares of the outputs of each run of the simulation
        real*8:: msObIons, msObExcites, msObElastics, msObGens, msObDiss, msObB1SuExc, msObC1PuExc
        real*8:: msObSingletExc, msObTripletExc, msObRad
        real*8:: msObSingletPerIonPair, msObTripletPerIonPair
        real*8:: msObB1SuIonPair, msObC1PuIonPair
        real*8:: msObW
        !Observed ncertainties(standard deviation) in the outputs of each run of the simulation
        real*8:: uIons, uExcites, uElastics, uGens, uDiss, uB1SuExc, uC1PuExc
        real*8:: uSingletExc, uTripletExc, uRad, uWInv
        real*8:: uB1SuPerIonPair, uC1PuPerIonPair
        real*8:: uSingletPerIonPair, uTripletPerIonPair
        real*8:: uB1SuIonPair, uC1PuIonPair
        real*8:: uW
        !Final unceratinties after subtractin statistical part
        real*8:: uIonsFin, uExcitesFin, uElasticsFin, uGensFin, uDissFin, uB1SuExcFin, uC1PuExcFin
        real*8:: uSingletExcFin, uTripletExcFin, uRadFin, uWInvFin
        real*8:: uB1SuPerIonPairFin, uC1PuPerIonPairFin
        real*8:: uSingletPerIonPairFin, uTripletPerIonPairFin
        real*8:: uB1SuIonPairFin, uC1PuIonPairFin
        real*8:: uWFin
        !Statistical uncertainties 
        real*8:: uStatIons, uStatExcites, uStatGens, uStatDiss
        real*8:: uStatB1SuExc, uStatC1PuExc, uStatSingletExc, uStatTripletExc
        real*8:: uStatRad, uStatSingletPerIonPair, uStatTripletPerIonPair
        real*8:: uStatB1SuIonPair, uStatC1PuIonPair
        real*8:: uStatW
 
        !Find the mean and standard deviation of each of the calculated
        !quantities in each of the runs
        mObIons = 0.0d0
        mObW = 0.0d0
        mObExcites = 0.0d0
        mObElastics = 0.0d0
        mObGens = 0.0d0
        mObDiss = 0.0d0
        mObB1SuExc = 0.0d0
        mObC1PuExc = 0.0d0
        mObSingletExc = 0.0d0
        mObTripletExc = 0.0d0
        mObRad = 0.0d0
        mObB1SuIonPair = 0.0d0
        mObC1PuIonPair = 0.0d0

        msObIons = 0.0d0
        msObW = 0.0d0
        msObExcites = 0.0d0
        msObElastics = 0.0d0
        msObGens = 0.0d0
        msObDiss = 0.0d0
        msObB1SuExc = 0.0d0
        msObC1PuExc = 0.0d0
        msObSingletExc = 0.0d0
        msObTripletExc = 0.0d0
        msObRad = 0.0d0
        msObB1SuIonPair = 0.0d0
        msObC1PuIonPair = 0.0d0

        uStatIons = 0.0d0
        uStatW = 0.0d0
        uStatExcites = 0.0d0
        !uStatElastics = uStat
        uStatGens = 0.0d0
        uStatDiss = 0.0d0
        uStatB1SuExc = 0.0d0
        uStatC1PuExc = 0.0d0
        uStatSingletExc = 0.0d0
        uStatTripletExc = 0.0d0
        uStatRad = 0.0d0
        uStatSingletPerIonPair = 0.0d0
        uStatTripletPerIonPair = 0.0d0
        uStatB1SuIonPair = 0.0d0
        uStatC1PuIonPair = 0.0d0

        numSimsVal = 0
        do ii= 1, data_in%totalVariations
           numSimsVal = datamcArray(ii)%numSims
           !print*, mIons, datamcArray(ii)%secE, dble(datamcArray(ii)%secE)/dble(numSimsVal)           

           !Sum statistical uncertainties 
           uStatIons = uStatIons + (datamcArray(ii)%mssecE - datamcArray(ii)%msecE**2)/dble(numSimsVal) 
           uStatW = uStatW + (datamcArray(ii)%msW - datamcArraY(ii)%mW**2)/dble(numSimsVal)
           uStatExcites = uStatExcites + (datamcArray(ii)%msexcite - datamcArray(ii)%mexcite**2)/dble(numSimsVal)
           !uStatElastics = uStatElastics + (datamcArray(ii)%ms - datamcArray(ii)%m  ) 
           uStatGens = uStatGens + (datamcArray(ii)%msgen - datamcArray(ii)%mgen**2)/dble(numSimsVal) 
           uStatDiss = uStatDiss + (datamcArray(ii)%msdissociations - datamcArray(ii)%mdissociations**2)/dble(numSimsVal) 
           uStatB1SuExc = uStatB1SuExc + (datamcArray(ii)%msB1SuExc - datamcArray(ii)%mB1SuExc**2)/dble(numSimsVal) 
           uStatC1PuExc = uStatC1PuExc + (datamcArray(ii)%msC1PuExc - datamcArray(ii)%mC1PuExc**2)/dble(numSimsVal) 
           uStatSingletExc = uStatSingletExc + (datamcArray(ii)%mssingletExc - datamcArray(ii)%msingletExc**2)/dble(numSimsVal) 
           uStatTripletExc = uStatTripletExc + (datamcArray(ii)%mstripletExc - datamcArray(ii)%mtripletExc**2)/dble(numSimsVal) 
           uStatRad = uStatRad + (datamcArray(ii)%msinERad - datamcArray(ii)%minERad**2)/dble(numSimsVal) 
           uStatSingletPerIonPair = uStatSingletPerIonPair + (datamcArray(ii)%msSingIonPair - datamcArray(ii)%mSingIonPair**2)/dble(numSimsVal)
           uStatTripletPerIonPair = uStatTripletPerIonPair + (datamcArray(ii)%msTripIonPair - datamcArray(ii)%mTripIonPair**2)/dble(numSimsVal) 
           uStatB1SuIonPair = uStatB1SuIonPair + (datamcArray(ii)%msB1SuIonPair - datamcArray(ii)%mB1SuIonPair**2)/dble(numSimsVal)
           uStatC1PuIonPair = uStatC1PuIonPair + (datamcArray(ii)%msC1PuIonPair - datamcArray(ii)%mC1PuIonPair**2)/dble(numSimsVal)

           !Calculate observed mean square and mean
           mObIons = mObIons + dble(datamcArray(ii)%secE)/dble(numSimsVal)
           mObW = mObW + dble(datamcArray(ii)%W)/dble(numSimsVal) 
           mObExcites = mObExcites + dble(datamcArray(ii)%excite)/dble(numSimsVal)
           mObElastics = mObElastics + dble(datamcArray(ii)%elastic)/dble(numSimsVal)
           mObGens = mObGens + dble(datamcArray(ii)%gen)/dble(numSimsVal)
           mObDiss = mObDiss + dble(datamcArray(ii)%dissociations)/dble(numSimsVal)
           mObB1SuExc = mObB1SuExc + dble(datamcArray(ii)%B1SuExc)/dble(numSimsVal)
           mObC1PuExc = mObC1PuExc + dble(datamcArray(ii)%C1PuExc)/dble(numSimsVal)
           mObSingletExc = mObSingletExc + dble(datamcArray(ii)%singletExc)/dble(numSimsVal)
           mObTripletExc = mObTripletExc + dble(datamcArray(ii)%tripletExc)/dble(numSimsVal)
           mObRad = mObRad + dble(datamcArray(ii)%inERad)/dble(numSimsVal)
           mObSingletPerIonPair = mObSingletPerIonPair + dble(datamcArray(ii)%singIonPair)/dble(numSimsVal) 
           mObTripletPerIonPair = mObTripletPerIonPair + dble(datamcArray(ii)%tripIonPair)/dble(numSimsVal)
           mObB1SuIonPair = mObB1SuIonPair + dble(datamcArray(ii)%B1SuIonPair)/dble(numSimsVal)
           mObC1PuIonPair = mObC1PuIonPair + dble(datamcArray(ii)%C1PuIonPair)/dble(numSimsVal)
 
           msObIons = msObIons + (dble(datamcArray(ii)%secE)/dble(numSimsVal))**2
           msObW = msObW + (dble(datamcArray(ii)%W)/dble(numSimsVal))**2 
           msObExcites = msObExcites + (dble((datamcArray(ii)%excite))/dble(numSimsVal))**2
           msObElastics =  msObElastics + (dble((datamcArray(ii)%elastic))/dble(numSimsVal))**2
           msObGens = msObGens + (dble((datamcArray(ii)%gen))/dble(numSimsVal))**2
           msObDiss = msObDiss + (dble((datamcArray(ii)%dissociations))/dble(numSimsVal))**2
           msObB1SuExc = msObB1SuExc + (dble((datamcArray(ii)%B1SuExc))/dble(numSimsVal))**2
           msObC1PuExc = msObC1PuExc + (dble((datamcArray(ii)%C1PuExc))/dble(numSimsVal))**2
           msObSingletExc = msObSingletExc + (dble((datamcArray(ii)%singletExc))/dble(numSimsVal))**2
           msObTripletExc = msObTripletExc + (dble((datamcArray(ii)%tripletExc))/dble(numSimsVal))**2
           msObRad = msObRad + (dble((datamcArray(ii)%inERad))/dble(numSimsVal))**2
           msObSingletPerIonPair = msObSingletPerIonPair + (dble(datamcArray(ii)%singIonPair)/dble(numSimsVal))**2
           msObTripletPerIonPair = msObTripletPerIonPair + (dble(datamcArray(ii)%tripIonPair)/dble(numSimsVal))**2
           msObB1SuIonPair = msObB1SuIonPair + (dble(datamcArray(ii)%B1SuIonPair)/dble(numSimsVal))**2
           msObC1PuIonPair = msObC1PuIonPair + (dble(datamcArray(ii)%C1PuIonPair)/dble(numSimsVal))**2 
        end do

        print*, "W recorded" 
        print*, msObW
        print*, mObW



        !Better to use formulas from sokolnikoff
        !Uncertainties in outputs due to varying input values:
        !- Var(X) approx = (1/(N-1))*(sum(X_j^2) - (1/N)*(sum(X_j)^2))
        !- E(X) approx = (1/N)*sum(X_j)
      
        !Same, but from paper:
        ! - sigma_{obs}^2 = (1/(N-1))*sum((X_j-XBar)^2)
        !These are actually the same formula.
        !For large N this is essentially: mean(X^2) - (mean(X))^2

        uStatIons = uStatIons/dble(data_in%totalVariations)
        uStatW = uStatW/dble(data_in%totalVariations)
        uStatExcites = uStatExcites/dble(data_in%totalVariations)
        uStatGens = uStatGens/dble(data_in%totalVariations)
        uStatDiss = uStatDiss/dble(data_in%totalVariations)
        uStatB1SuExc = uStatB1SuExc/dble(data_in%totalVariations)
        uStatC1PuExc = uStatC1PuExc/dble(data_in%totalVariations)
        uStatSingletExc = uStatSingletExc/dble(data_in%totalVariations)
        uStatTripletExc = uStatTripletExc/dble(data_in%totalVariations)
        uStatRad = uStatRad/dble(data_in%totalVariations)
        uStatSingletPerIonPair = uStatSingletPerIonPair/dble(data_in%totalVariations)
        uStatTripletPerIonPair = uStatTripletPerIonPair/dble(data_in%totalVariations)
        uStatB1SuIonPair = uStatB1SuIonPair/dble(data_in%totalVariations)
        uStatC1PuIonPair = uStatC1PuIonPair/dble(data_in%totalVariations)   

        print*, "TotalVars"
        print*, dble(data_in%totalVariations)


        print*, "UStat"
        print*, sqrt(uStatIons)
        print*, sqrt(uStatW)
        print*, sqrt(uStatExcites)
        print*, sqrt(uStatGens)
        print*, sqrt(uStatDiss)
        print*, sqrt(uStatB1SuExc)
        print*, sqrt(uStatC1PuExc)
        print*, sqrt(uStatSingletExc)
        print*, sqrt(uStatTripletExc)
        print*, sqrt(uStatRad)
        print*, sqrt(uStatSingletPerIonPair)
        print*, sqrt(uStatTripletPerIonPair)
        print*, sqrt(uStatB1SuIonPair)
        print*, sqrt(uStatC1PuIonPair)

        mObIons = mObIons/dble(data_input%totalVariations)
        mObW = mObW/dble(data_input%totalVariations)
        mObExcites = mObExcites/dble(data_input%totalVariations)
        mObElastics = mObElastics/dble(data_input%totalVariations) 
        mObGens = mObGens/dble(data_input%totalVariations) 
        mObDiss = mObDiss/dble(data_input%totalVariations)
        mObB1SuExc = mObB1SuExc/dble(data_input%totalVariations) 
        mObC1PuExc = mObC1PuExc/dble(data_input%totalVariations)
        mObSingletExc = mObSingletExc/dble(data_input%totalVariations)
        mObTripletExc = mObTripletExc/dble(data_input%totalVariations) 
        mObRad = mObRad/dble(data_input%totalVariations) 
        mObSingletPerIonPair = mObSingletPerIonPair/dble(data_input%totalVariations)                     
        mObTripletPerIonPair = mObTripletPerIonPair/dble(data_input%totalVariations)                     
        mObB1SuIonPair = mObB1SuIonPair/dble(data_input%totalVariations)
        mObC1PuIonPair = mObC1PuIonPair/dble(data_input%totalVariations)
 
        msObIons = msObIons/dble(data_input%totalVariations) 
        msObW = msObW/dble(data_input%totalVariations)
        msObExcites = msObExcites/dble(data_input%totalVariations) 
        msObElastics = msObElastics/dble(data_input%totalVariations) 
        msObGens = msObGens/dble(data_input%totalVariations)
        msObDiss = msObDiss/dble(data_input%totalVariations)
        msObB1SuExc = msObB1SuExc/dble(data_input%totalVariations) 
        msObC1PuExc = msObC1PuExc/dble(data_input%totalVariations) 
        msObSingletExc = msObSingletExc/dble(data_input%totalVariations) 
        msObTripletExc = msObTripletExc/dble(data_input%totalVariations) 
        msObRad = msObRad/dble(data_input%totalVariations) 
        msObSingletPerIonPair = msObSingletPerIonPair/dble(data_input%totalVariations)
        msObTripletPerIonPair = msObTripletPerIonPair/dble(data_input%totalVariations)
        msObB1SuIonPair = msObB1SuIonPair/dble(data_input%totalVariations)
        msObC1PuIonPair = msObC1PuIonPair/dble(data_input%totalVariations)


        uIons = sqrt((msObIons-mObIons**2)*(dble(data_input%totalVariations)/dble(data_input%totalVariations-1)))   
        uW = sqrt((msObW - mObW**2)*(dble(data_input%totalVariations)/dble(data_input%totalVariations-1)))
        uExcites = sqrt((msObExcites-mObExcites**2)*(dble(data_input%totalVariations)/dble(data_input%totalVariations-1)))
        uElastics = sqrt((msObElastics-mObElastics**2)*(dble(data_input%totalVariations)/dble(data_input%totalVariations-1)))
        uGens = sqrt((msObGens-mObGens**2)*(dble(data_input%totalVariations)/dble(data_input%totalVariations-1)))
        uDiss = sqrt((msObDiss-mObDiss**2)*(dble(data_input%totalVariations)/dble(data_input%totalVariations-1)))
        uB1SuExc = sqrt((msObB1SuExc-mObB1SuExc**2)*(dble(data_input%totalVariations)/dble(data_input%totalVariations-1)))
        uC1PuExc = sqrt((msObC1PuExc-mObC1PuExc**2)*(dble(data_input%totalVariations)/dble(data_input%totalVariations-1)))
        uSingletExc = sqrt((msObSingletExc-mObSingletExc**2)*(dble(data_input%totalVariations)/dble(data_input%totalVariations-1)))
        uTripletExc = sqrt((msObTripletExc-mObTripletExc**2)*(dble(data_input%totalVariations)/dble(data_input%totalVariations-1)))
        uRad = sqrt((msObRad-mObRad**2)*(dble(data_input%totalVariations)/dble(data_input%totalVariations-1)))
        uSingletPerIonPair = sqrt((msObSingletPerIonPair - mObSingletPerIonPair**2)*(dble(data_input%totalVariations)/dble(data_input%totalVariations-1)))
        uTripletPerIonPair = sqrt((msObTripletPerIonPair - mObTripletPerIonPair**2)*(dble(data_input%totalVariations)/dble(data_input%totalVariations-1)))
        uB1SuIonPair = sqrt((msObB1SuIonPair-mObB1SuIonPair**2)*(dble(data_input%totalVariations)/dble(data_input%totalVariations-1))) 
        uC1PuIonPair = sqrt((msObC1PuIonPair-mObC1PuIonPair**2)*(dble(data_input%totalVariations)/dble(data_input%totalVariations-1)))

        print*, "U without stat"
        print*, uIons 
        print*, uW
        print*, uExcites 
        print*, uGens 
        print*, uDiss 
        print*, uB1SuExc 
        print*, uC1PuExc 
        print*, uSingletExc 
        print*, uTripletExc 
        print*, uRad 
        print*, uSingletPerIonPair
        print*, uTripletPerIonPair
        print*, uB1SuIonPair
        print*, uC1PuIonPair

        !Subtract statistical uncertainty to get final result. This is
        !sigma(input) = sqrt( sigma(observed)^2 - sigma(statistical)^2)
        uIonsFin = sqrt(uIons**2 - uStatIons)   !uStatIons actually stores mean variance
        uWFin = sqrt(uW**2 - uStatW)
        uExcitesFin = sqrt(uExcites**2 - uStatExcites)
        uGensFin = sqrt(uGens**2 - uStatGens)
        uDissFin = sqrt(uDiss**2 - uStatDiss)
        uB1SuExcFin = sqrt(uB1SuExc**2 - uStatB1SuExc)
        uC1PuExcFin = sqrt(uC1PuExc**2 - uStatC1PuExc)
        uSingletExcFin = sqrt(uSingletExc**2 - uStatSingletExc)
        uTripletExcFin = sqrt(uTripletExc**2 - uStatTripletExc)
        uRadFin = sqrt(uRad**2 - uStatRad)
        uSingletPerIonPairFin = sqrt(uSingletPerIonPair**2 - uStatSingletPerIonPair)  
        uTripletPerIonPairFin = sqrt(uTripletPerIonPair**2 - uStatTripletPerIonPair)
        uB1SuIonPairFin = sqrt(uB1SuIonPair**2 - uStatB1SuIonPair)
        uC1PuIonPairFin = sqrt(uC1PuIonPair**2 - uStatC1PuIonPair) 

        !Calculate any additional uncertainties depending on the above values.
        !uWInv = uW/((data_input%energy*data_input%eV/mObIons)**2)
        !uB1SuPerIonPair = (mObB1SuExc/mObIons)*sqrt((uB1SuExc/mObB1SuExc)**2 + (uIons/mObIons)**2) 
        !uC1PuPerIonPair = (mObC1PuExc/mObIons)*sqrt((uC1PuExc/mObC1PuExc)**2 + (uIons/mObIons)**2)

        !Print these uncertainties to file.
        open(70, file='diagnostics.txt')
        !write(70,*) "Mean Variances"
        !write(70,*) "_______________________________________________________"
        !write(70,*) "Ions: ",  uStatIons
        !write(70,*) "Excites: ", uStatExcites 
        !write(70,*) "Gens: ", uStatGens 
        !write(70,*) "Dissociations: ", uStatDiss 
        !write(70,*) "B1SuExc: ", uStatB1SuExc 
        !write(70,*) "C1PuExc: ", uStatC1PuExc 
        !write(70,*) "singletExc: ", uStatSingletExc
        !write(70,*) "tripletExc: ", uStatTripletExc
        !write(70,*) "rad: ", uStatRad 
        !write(70,*) "singletPerIonPair: ", uStatSingletPerIonPair
        !write(70,*) "tripletPerIonPair: ", uStatTripletPerIonPair

        write(70,*) "Incident energy (eV): ", data_input%energy*data_input%eV
        write(70,*) "Mean Values"
        write(70,*) "-----------------------------------------------------"
        write(70,*) "mean number of ionisations: ", mObIons
        write(70,*) "mean energy per ion pair: ", mObW
        write(70,*) "mean number of excitations: ", mObExcites
!        write(70,*) "mean number of elastic scattering events: ", mObElastics
        write(70,*) "mean number of generations: ", mObGens
        write(70,*) "mean number of dissociations: ", mObDiss
        write(70,*) "mean number of B1Su excitations: ", mObB1SuExc
        write(70,*) "mean number of C1Pu excitations: ", mObC1PuExc
        write(70,*) "mean number of singlet excitations: ", mObSingletExc
        write(70,*) "mean number of triplet excitations: ", mObTripletExc
        write(70,*) "mean final radius: ", mObRad

        write(70,*) "Uncertainties"
        write(70,*) "-----------------------------------------------------"
        write(70,*) "u(ionisations): ", uIonsFin
        write(70,*) "u(mean energy per ion pair): ", uWFin
        write(70,*) "u(num excitations): ", uExcitesFin
!        write(70,*) "u(num elastic colls): ", uElasticsFin
        write(70,*) "u(num generations): ", uGensFin
        write(70,*) "u(num dissociations): ", uDissFin
       ! write(70,*) "u(1/mean energy per ion pair):", uWInvFin
        write(70,*) "u(B1SuPerIonPair):", uB1SuPerIonPairFin
        write(70,*) "u(C1PuPerIonPair):", uC1PuPerIonPairFin
        write(70,*) "u(num B1Su excitations): ", uB1SuExcFin
        write(70,*) "u(num C1Pu excitations): ", uC1PuExcFin
        write(70,*) "u(num singlet excitations): ", uSingletExcFin
        write(70,*) "u(num triplet excitations): ", uTripletExcFin
        write(70,*) "u(num singlet excitations per ion pair): ", uSingletPerIonPairFin
        write(70,*) "u(num triplet excitations per ion pair): ", uTripletPerIonPairFin
        write(70,*) "u(num B1Su excitations per ion pair): ", uB1SuIonPairFin
        write(70,*) "u(num C1Pu excitations per ion pair): ", uC1PuIonPairFin
        write(70,*) "u(final radius): ", uRadFin

        write(70,*) "Observed Standard Deviations"
        write(70,*) "_______________________________________________________" 
        write(70,*) "sigmaOb(ionisations): ", uIons
        write(70,*) "sigmaOb(mean energy per ion pair): ", uW
        write(70,*) "sigmaOb(num excitations): ", uExcites
!        write(70,*) "sigmaOb(num elastic colls): ", uElastics
        write(70,*) "sigmaOb(num generations): ", uGens
        write(70,*) "sigmaOb(num dissociations): ", uDiss
        write(70,*) "sigmaOb(mean energy per ion pair):", uW
        !write(70,*) "sigmaOb(1/mean energy per ion pair):", uWInv
        write(70,*) "sigmaOb(B1SuPerIonPair):", uB1SuPerIonPair
        write(70,*) "sigmaOb(C1PuPerIonPair):", uC1PuPerIonPair
        write(70,*) "sigmaOb(num B1Su excitations): ", uB1SuExc
        write(70,*) "sigmaOb(num C1Pu excitations): ", uC1PuExc
        write(70,*) "sigmaOb(num singlet excitations): ", uSingletExc
        write(70,*) "sigmaOb(num triplet excitations): ", uTripletExc
        write(70,*) "sigmaOb(num singlet excitations per ion pair): ", uSingletPerIonPair
        write(70,*) "sigmaOb(num triplet excitations per ion pair): ", uTripletPerIonPair
        write(70,*) "sigmaOb(num B1Su excitations per ion pair): ", uB1SuIonPair
        write(70,*) "sigmaOb(num C1Pu excitations per ion pair): ", uC1PuIonPair
        write(70,*) "sigmaOb(final radius): ", uRad


        close(70)

    end subroutine calculateErrors


!    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!    !Subroutine: calculateStatErr 
!    !Purpose: calculates standard deviation of simulation output values
!    !         using previously recorded first and second moments of 
!    !         simulated distribution.
!    !Date last modified: 23/06/2021
!    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!    subroutine calculateStatErr(datamc,data_input)
!       use input_data
!       implicit none
!       type(simdata)::datamc
!       type(input):: data_input
!       real*8:: uSecE, uExcite, uDiss, uGen, uInERad
!       real*8:: uB1SuExc, uC1PuExc, uSingletExc, uTripletExc
!
!       uSecE = sqrt(datamc%mssecE - (datamc%msecE)**2)
!       uExcite = sqrt(datamc%msexcite - (datamc%mexcite)**2)
!       uDiss = sqrt(datamc%msdissociations - (datamc%mdissociations)**2) 
!       uGen = sqrt(datamc%msgen - (datamc%mgen)**2)
!       uInERad = sqrt(datamc%msinERad - (datamc%minERad)**2)
!       uB1SuExc = sqrt(datamc%msB1SuExc - (datamc%mB1SuExc)**2)
!       uC1PuExc = sqrt(datamc%msC1PuExc - (datamc%mC1PuExc)**2)
!       uSingletExc = sqrt(datamc%mssingletExc - (datamc%msingletExc)**2) 
!       uTripletExc = sqrt(datamc%mstripletExc - (datamc%mtripletExc)**2)
!
!       open(70,file='statErr.txt')
!       write(70,*) "Incident energy (eV): ", data_input%energy*data_input%eV
!       write(70,*) "Standard Deviations (Statistical Uncertainties)"
!       write(70,*) "______________________________________________________"
!       write(70,*) "u(secE): ", uSecE
!       write(70,*) "u(excitations): ", uExcite
!       write(70,*) "u(dissociations): ", uDiss
!       write(70,*) "u(gen): ", uGen
!       write(70,*) "u(incident electron radius): ", uInERad
!       write(70,*) "u(B1Su excitations): ", uB1SuExc
!       write(70,*) "u(C1Pu excitations): ", uC1PuExc
!       write(70,*) "u(singlet excitations): ", uSingletExc
!       write(70,*) "u(triplet excitations): ", uTripletExc
!       close(70)
!
!
!    end subroutine calculateStatErr





end module mc
