module mc 
	public::  update_energy,init_simdata,init_particle
	
	type, public:: particle
	
		real*8,dimension(0:70000):: energy ! The energy at each collision
		real*8,dimension(0:70000):: enArr ! The energy target energy at each collision
		integer:: gen ! Which generation the particle was created in
		integer:: colls ! Total number of collisions the particle undergoes
		integer,dimension(0:70000):: state ! The state selected at each collision
		logical,dimension(0:70000):: diss	! True if dissociation occured at that collision
		real*8,dimension(0:70000):: costheta ! Cosine of the scattering angle at each collision 
                real*8,dimension(0:70000):: phi     !Azimuthal scattering angle randomly generated after each collision	
		logical,dimension(0:70000):: Ps	! True if Ps Formation occured at that collision (only used for Ps Formation Benchmark Simulation)
                real*8,dimension(0:70000)::path !Stores path length after each collisions	
 
	end type particle
	
	type, public:: simdata ! Data for the simulation of ONE incident particle
	
		integer:: secE ! total number of secondary electrons created in this simulation (num of ionisations)		
		integer:: excite ! total number of excitation collisions created in this simulation
		integer:: elastic ! total number of elastic collisions created in this simulation
		integer:: dissociations ! total number of dissociations in this simulation
		integer:: gen ! total number of sec E generations created in this simulation
		integer:: genIndex ! Current generation 
		integer,dimension(1000):: ePerGen ! Number of electrons in each generation
		real*8,dimension(1000):: enPerGen ! Total energy of electrons in each generation
		integer,dimension(0:1000):: dissPerGen ! Dissociation count per generation
		!integer,dimension(0:1000):: ionPerGen ! number of ionisations in each gen 
		integer,dimension(0:1000):: excPerGen ! number of excitation collisions in each gen
		integer,dimension(0:1000):: elPerGen ! number of elastic collisions in each gen 
		integer,dimension(0:1000):: collPerGen ! number of collisions in each gen 
	       
                !Data recorded for program consistency checks
                real*8, dimension(0:1000):: ejEnGrid !Grid of ejection energies in ionisation
                integer,dimension(0:1000):: numEj !Number of ionisations at a given energy in above grid 	
				
		! For Ps Benchmark Simulation
		logical:: PsFormed ! True if Positronium is Formed (exit condition for simulation loop)
		integer:: numPsFormed
		real*8 :: duration,tResTemp,tRes
		
	end type simdata
	
	contains
	
	subroutine init_particle(self,initE,gen) ! Initialise particle values
	
		type(particle),intent(inout):: self
		real*8,intent(in):: initE
		integer,intent(in):: gen
		
	        self%energy(:) = 0.0
		self%state(:) = 0
		self%diss(:) = .FALSE.
		self%costheta(:) = 0.0
		self%Ps(:) = .FALSE.
                self%path(:) = 0.0
				
		self%energy(0) = initE
		self%gen = gen		
		self%colls = 0
	
	end subroutine init_particle
	
	
	subroutine init_simdata(self) ! Initialise data for ONE simulation
	
		implicit none
		type(simdata), intent(inout):: self
		integer:: i
                real*8:: en	
	
		self%secE = 0
		self%gen = 0
		self%excite = 0
		self%elastic = 0
		self%dissociations = 0
		
		self%PsFormed = .false.
		self%numPsFormed = 0
		self%duration = 0.0
		self%tResTemp = 0.0
		self%tRes = 0.0
		
		do i = 1,1000
			self%ePerGen(i) = 0
			self%enPerGen(i) = 0.0
		end do
		
		do i = 0,1000
			self%dissPerGen(i) = 0
			!self%ionPerGen(i) = 0
			self%excPerGen(i) = 0
			self%elPerGen(i) = 0
			self%collPerGen(i) = 0
		end do

                en = 0.0
                do i =1, 1000
                   self%ejEnGrid(i) = en
                   en = en + 0.5
                end do
                self%numEj(:) = 0


	end subroutine init_simdata


   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   !Subroutine: recordEjEn
   !Purpose: records the ejection energy chosen using one of several
   !         distributions for ionisation.
   !Date last modified: 15/07/2020
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   subroutine recordEjEn(energy, datasim)
       implicit none
       type(simdata)::datasim
       real*8:: energy
       logical:: found
       integer:: ii

       found = .false.
       !Find energy range in grid chosen energy falls into
       
       ii = 1
       do while (.not. found)
          if (energy .gt. datasim%ejEnGrid(ii)) then
             ii = ii + 1
          else 
             found = .true.
          end if 
       end do
           
       !Increment number in a particular range
       datasim%numEj(ii) = datasim%numEj(ii) +1
   end subroutine recordEjEn








	
    subroutine update_energy(statebasis,sdcsBasis,vcsBasis,dcsBasis,stateNum,tcs,particlebasis,minExcEn,partNum,coll,ionop,enlossop,datasim,bmode,VarPs)
        use state_class
        use totalcs_module
        use Ps_module
        use sdcs_module
        use input_data
        use dcs_module
        implicit none
		
	type(basis_state),intent(in):: statebasis
	type(state):: selstate
        type(basis_sdcs)::sdcsBasis
        type(basis_vcs)::vcsBasis
        type(sdcs)::sdcsAtEIn
        type(vcs)::vcsIn
	integer, intent(in):: stateNum
	type(particle),dimension(0:1000),intent(inout):: particlebasis
	integer,intent(in):: partNum,coll, enlossop
	character (len=60),intent(in):: ionop ! Ionistation option
	type(totalcs):: tcs ! used to calculate the mean excitation energy
	type(simdata), intent(inout):: datasim		
	real*8:: enex,en ! excitation and ionisation energy (eV)
        real*8:: enexVib ! vibrational excitation energy
	real*8:: meanexc ! mean excitation energy (eV)
	real*8:: elEnergyLoss	  ! energy lost by incident particle (eV)
        real*8:: inElEnergyLoss   !energy loss in inelastic scattering, includes internal energy
        real*8:: ejEn, secE, primaryE, eIon, ejEnSelected, eIn
        real*8:: minExcEn !Minimum target electron excitation energy
        logical:: indist
	! For Ps Benchmark Simulation
	type(PsVar),intent(in):: VarPs 
	logical,intent(in):: bmode
        ! For debugging
        integer:: stateNumDebug
        logical:: debug
        type(totalcs)::tcsDebug
        type(sdcs)::sdcsDebug		
        type(basis_dcs)::dcsBasis
        debug = .false.
        
        eIon = 15.96632 !Ionisation energy of ground state H2 (eV)	
        eIn = particlebasis(partNum)%energy(coll)

	! The state that has been selected
        !Note that tcs stores energy in a.u, not eV
        !if (data_in%ionop .eq. 'state_distribution') then
        en = 0.0
        if (data_in%stateIonop .eq. 1) then
           !Use symmetrised pseudostates
           if (tcs%en(stateNum)*data_in%eV .lt. 0.0) then
              selstate = statebasis%b(stateNum) 
   	      enex =  selstate%enex
    	      en = selstate%en
           else if (tcs%en(stateNum)*data_in%eV .gt. 0.0) then
              en = tcs%en(stateNum)*data_in%eV
           end if
        else if (data_in%stateIonop .eq. 0) then 
           selstate = statebasis%b(stateNum) 
           enex =  selstate%enex
           en = selstate%en
        end if
        call getIndist(bmode,indist) 	


	!print*, 'particle',partNum,'gen',particlebasis(partNum)%gen,'coll',coll
	!print*, 'enex',enex
	!print*, 'preCollEnergy',particlebasis(partNum)%energy(coll)
	
	!print*, 'el cs', tcs%CS(1)
	!print*, 'exc cs', tcs%CS(2)
	!print*, 'ion cs', tcs%CS(3)
	!print*, 'Ps cs', tcs%CS(4)
        particlebasis(partNum)%enArr(coll) = en


	if (stateNum == 1) then ! elastic collision					
	   datasim%elastic = datasim%elastic + 1	! Update total elastic scattering count for this simulation
	   datasim%elPerGen(particlebasis(partNum)%gen) = datasim%elPerGen(particlebasis(partNum)%gen) + 1 ! Update total elastic scattering count for this generation
	   call elasticScattering(particlebasis(partNum)%energy(coll),particlebasis(partNum)%costheta(coll),elEnergyLoss,bmode,dcsBasis) 
	   particlebasis(partNum)%energy(coll + 1) = particlebasis(partNum)%energy(coll) - elEnergyLoss 
				
	else if(en < 0) then ! excitation collision 
	   datasim%excite = datasim%excite + 1 
	   datasim%excPerGen(particlebasis(partNum)%gen) = datasim%excPerGen(particlebasis(partNum)%gen) + 1 ! Update total excitation count for this generation
			
	   if(bmode) then
	      call elasticScattering(particlebasis(partNum)%energy(coll),particlebasis(partNum)%costheta(coll),elEnergyLoss,bmode,dcsBasis) 
	      particlebasis(partNum)%energy(coll + 1) = particlebasis(partNum)%energy(coll) - enex - elEnergyLoss
	   else
              if (enlossop .eq. 1) then
                 !Use only excitation energy of selected state                 
	         particlebasis(partNum)%energy(coll + 1) = particlebasis(partNum)%energy(coll) - enex
              else if (enlossop .eq. 2) then
                 !Use inelastic formula 
                 call inelasticScattering(particlebasis(partNum)%energy(coll),enex,particlebasis(partNum)%costheta(coll),inElEnergyLoss,bmode) 	
                 !Formula used for inelastic scattering includes loss
                 !to internal energy.
                 particlebasis(partNum)%energy(coll + 1) = particlebasis(partNum)%energy(coll) - inElEnergyLoss
              end if
	   end if	
	
        else if((stateNum .gt. 1) .and. (en > 0)) then ! ionisation collision 
	   datasim%secE = datasim%secE + 1 ! Increment number of secondary electrons created
	   datasim%gen = particlebasis(partNum)%gen + 1 ! Keep track of the number of generations that have been created
           datasim%ePerGen(particlebasis(partNum)%gen + 1) = datasim%ePerGen(particlebasis(partNum)%gen+1) + 1 ! Keep track of number of electrons in the next generation
			
	   if(bmode) then	! Only for Ps Benchmark Simulation
	      particlebasis(partNum)%energy(coll + 1) = VarPs%Q * (particlebasis(partNum)%energy(coll) - VarPs%e_ion)
	      !print*, 'Q',VarPs%Q
	   else ! For Default Simulation
              if(data_in%stateIonop .eq. 1) then
                 !tcs object energy grid in Hartees, need to convert
                 enex = tcs%en(stateNum)*data_in%eV
              end if

	      if(ionop.EQ.'mean') then ! mean excitation energy will be used
	         call meanexcenergy(tcs,statebasis,meanexc)

                 !Note; don't need to deal with indistinguishibility yet, as meanexc is
                 !      always below (eIn-eIon)/2.0
                 !ejEnSelected = meanexc
                 !Deal with particle indistinguishibility		
                 !if (indist) then
                 !   if (ejEnSelected .gt. (eIn-eIon)/2.0) then
                    !Above cutoff energy, energy selected is that of incident e        
                 !      secE = eIn-ejEnSelected
                 !      primaryE = ejEnSelected-eIon
                 !   else 
                 !      secE = ejEnSelected-eIon
                 !      primaryE = eIn-ejEnselected
                 !   end if
                 !end if

                 !particlebasis(partNum)%energy(coll+1) = primaryE 
		 !call init_particle(particlebasis(datasim%secE),secE,particlebasis(partNum)%gen + 1)			
		 !datasim%enPerGen(particlebasis(partNum)%gen + 1) = datasim%enPerGen(particlebasis(partNum)%gen+1) + secE

	         particlebasis(partNum)%energy(coll + 1) = particlebasis(partNum)%energy(coll) - meanexc
	         ! sec E created with energy equal to the mean exc energy minus the ionisation potential, its generation is the one after the current generation
		 call init_particle(particlebasis(datasim%secE),meanexc-eIon,particlebasis(partNum)%gen + 1)			
		 datasim%enPerGen(particlebasis(partNum)%gen + 1) = datasim%enPerGen(particlebasis(partNum)%gen+1) + (meanexc-eIon)
			
		 ! if((partNum.eq.0) .and.(coll.eq.0)) then
		   ! call meanexcenergy(tcs,statebasis,meanexc)
		 ! end if
                 !ejEnSelected = meanexc - eIon
	      else if(ionop .EQ. 'state_distribution') then ! regular excitation energy will be used 
                 !Particle loses energy of pseudostate, subject to indistinguishability
                 !print*, 'enex', enex
                 !Use alternate method to select ejection energy from CCC CS
                     
                 if (enlossop .eq. 1) then
                    !Deal with indistinguishibility
                    ejEnSelected = enex
                    !print*, "IN:", eIn, "SEL:",ejEnSelected
                    if (indist) then
                       if (ejEnSelected .gt. (eIn-eIon)/2.0) then
                          !Above cutoff energy, energy selected is that of incident e       
                          secE = eIn-ejEnSelected-eIon
                          primaryE = ejEnSelected
                       else 
                          secE = ejEnSelected
                          primaryE = eIn-ejEnselected-eIon
                       end if
                    else
                       secE = enex-eIon
                       primaryE = eIn-enex
                    end if

	            particlebasis(partNum)%energy(coll + 1) = primaryE
	            !particlebasis(partNum)%energy(coll + 1) = particlebasis(partNum)%energy(coll) - enex
                 else if (enlossop .eq. 2) then
                    !Include recoil for inelastic collisions

                    !Deal with indistinguishibility
                    ejEnSelected = enex
                    if (indist) then
                       if (ejEnSelected .gt. (eIn-eIon)/2.0) then
                          !Above cutoff energy, energy selected is that of incident e        
                          call inelasticScattering(particlebasis(partNum)%energy(coll),eIn-enex,particlebasis(partNum)%costheta(coll),inElEnergyLoss,bmode)
                          secE = eIn-enex
                          primaryE = eIn-inElEnergyLoss 
                       else 
                          call inelasticScattering(particlebasis(partNum)%energy(coll),enex,particlebasis(partNum)%costheta(coll),inElEnergyLoss,bmode)
                          secE = enex
                          primaryE = eIn-inElEnergyLoss
                       end if
                    else
                       call inelasticScattering(particlebasis(partNum)%energy(coll),enex,particlebasis(partNum)%costheta(coll),inElEnergyLoss,bmode)
                       secE = enex-eIon
                       primaryE = eIn-inElEnergyLoss
                    end if
                    particlebasis(partNum)%energy(coll+1) = primaryE
                    !call inelasticScattering(particlebasis(partNum)%energy(coll),enex,particlebasis(partNum)%costheta(coll),inElEnergyLoss,bmode)
                    !particlebasis(partNum)%energy(coll+1) = particlebasis(partNum)%energy(coll) - inElEnergyLoss
                 end if
	         call init_particle(particlebasis(datasim%secE),secE,particlebasis(partNum)%gen + 1)
                 call recordEjEn(secE,datasim)
	         datasim%enPerGen(particlebasis(partNum)%gen + 1) = datasim%enPerGen(particlebasis(partNum)%gen+1) + secE

                 !ejEnSelected = en
	         ! sec E created with energy equal to positive cont. ionisation energy, its generation is the one after the current generation
	         !call init_particle(particlebasis(datasim%secE),en,particlebasis(partNum)%gen + 1)
                 !call recordEjEn(en,datasim)
	         !datasim%enPerGen(particlebasis(partNum)%gen + 1) = datasim%enPerGen(particlebasis(partNum)%gen+1) + en
	      else if(ionop .EQ. 'SDCS') then !Distribution from SDCS
                 !Instead fit all SDCS in preprocessing ig sdcsOp .eq. 1 
                 !if(data_in%SdcsOp .eq. 0) then
                 !   call get_sdcsatein(sdcsBasis,particlebasis(partNum)%energy(coll),sdcsAtEIn)
                 !else if (data_in%SdcsOp .eq. 1) then 
                 !   call get_sdcsateinfit(sdcsAtEIn,sdcsBasis,particlebasis(partNum)%energy(coll),stateBasis,data_in)
                 !May need to update for more general non-H2 case
                 !end if
 
                 call get_sdcsatein(sdcsBasis,particlebasis(partNum)%energy(coll),sdcsAtEIn)


                 if (debug) then
                    allocate(tcsDebug%CS(sdcsAtEIn%Ncgsdcs))
                    allocate(tcsDebug%en(sdcsAtEIn%Ncgsdcs))
                    tcsDebug%cs(:) = sdcsAtEIn%CS(:)
                    tcsDebug%en(:) = sdcsAtEIn%ecg(:) 
                    call selectstate(tcsDebug,particlebasis(partNum),coll,stateNumDebug)
                    ejEn = tcsDebug%en(stateNumDebug)
                    deallocate(tcsDebug%CS,tcsDebug%en)
                 else 
                    !Choose ejection energy, run monte carlo
                    call selectEjEn(sdcsAtEIn,ejEn) 
                 end if

                 !Deal with indistinguishability
                 ejEnSelected = ejEn	        
                 if (indist)  then
                    if (ejEnSelected .gt. (eIn-eIon)/2.0) then
                       !Above cutoff energy, energy selected is that of incident e        
                       secE = eIn-ejEnSelected-eIon
                       primaryE = ejEnSelected
                    else 
                       secE = ejEnSelected
                       primaryE = eIn-ejEnSelected-eIon
                    end if
                 else
                    secE = ejEn
                    primaryE = eIn-ejEnSelected-eIon
                 end if
                  
                 particlebasis(partNum)%energy(coll+1) = primaryE
	         call init_particle(particlebasis(datasim%secE),secE,particlebasis(partNum)%gen + 1)
                 datasim%enPerGen(particlebasis(partNum)%gen + 1) = datasim%enPerGen(particlebasis(partNum)%gen+1) + secE

                 !particlebasis(partNum)%energy(coll + 1) = particlebasis(partNum)%energy(coll) - (ejEn + eIon)				
	         !call init_particle(particlebasis(datasim%secE),ejEn,particlebasis(partNum)%gen + 1)
                 !datasim%enPerGen(particlebasis(partNum)%gen + 1) = datasim%enPerGen(particlebasis(partNum)%gen+1) + ejEn
                 call destructSdcsAtEIn(sdcsAtEIn)
                 call recordEjEn(secE,datasim)
                 !call recordEjEn(ejEn,datasim) !Record ejection energy chosen
              else if (ionop .eq. 'SDCSDist') then
                 !Use analytical distribution from Dalgarno paper
                 call getSdcsDistAtEIn(sdcsBasis,eIn,sdcsAtEIn,tcs,stateBasis)
                 call selectEjEn(sdcsAtEIn, ejEn) 
  
                 !print*, "EJEN: ", ejEn
                 !Deal with indistinguishability
                 !Use same method as symmetrised SDCS for consistency
                 ejEnSelected = ejEn	        
                 if (indist)  then
                    if (ejEnSelected .gt. (eIn-eIon)/2.0) then
                       !Above cutoff energy, energy selected is that of incident e        
                       secE = eIn-ejEnSelected-eIon
                       primaryE = ejEnSelected
                    else 
                       secE = ejEnSelected
                       primaryE = eIn-ejEnSelected-eIon
                    end if
                 else
                    secE = ejEn
                    primaryE = eIn-ejEnSelected-eIon
                 end if
               
                 particlebasis(partNum)%energy(coll+1) = primaryE
	         call init_particle(particlebasis(datasim%secE),secE,particlebasis(partNum)%gen + 1)
                 datasim%enPerGen(particlebasis(partNum)%gen + 1) = datasim%enPerGen(particlebasis(partNum)%gen+1) + secE
 
                 call destructSdcsAtEIn(sdcsAtEIn)
                 call recordEjEn(secE,datasim)
              end if
           end if	
           !particlebasis(partNum)%energy(coll+1) = primaryE
           !call init_particle(particlebasis(datasim%secE),secE,particlebasis(partNum)%gen+1)               
           !datasim%enPerGen(particlebasis(partNum)%gen + 1) = datasim%enPerGen(particlebasis(partNum)%gen+1) + secE
           !call recordEjEn(secE,datasim) !Record ejection energy chosen
        else
	   !write to an error file
        end if	
        !print*, 'postCollEnergy',particlebasis(partNum)%energy(coll + 1) 	
    end subroutine update_energy



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !Subroutine: getIndist
    !Purpose: indentifies whether or not scattered particles are
    !         indistinguishible
    !Date last modified: 20/09/2020
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    subroutine getIndist(bmode,indist)
        implicit none
        logical, intent(inout)::indist
        logical, intent(in):: bmode

        indist = .false.
        if (.not. bmode) then
           indist = .true.
        end if
    end subroutine

	
	subroutine dissociation(part,statebasis,stateNum,dicsBasis,tcs,datasim,data_input,coll)
                use input_data
                use state_class
		use totalcs_module	
		implicit none
		
                type(input)::data_input
		type(particle),intent(inout):: part
		type(totalcs),intent(in):: tcs
                type(basis_state),intent(in)::statebasis
		integer,intent(in):: stateNum, coll
                type(basis_dics),intent(in)::dicsBasis
                type(state)::selstate
		type(simdata), intent(inout):: datasim		
		logical:: diss	! True if dissociation occurs
		real*8:: df, randNum, en, enIncident
                	
                enIncident = part%energy(coll)

                !Find energy of selected state
                if (data_in%stateIonop .eq. 1) then
                   en = tcs%en(stateNum)  
                else if (data_in%stateIonop .eq. 0) then
                   selstate = statebasis%b(stateNum)
                   en = selstate%en
	        end if
           
		! Assume dissociation does not occur until proven otherwise
		diss = .FALSE.		

		! Get the dissociation fraction for selected state at current energy
                if (data_input%dicsop .eq. 1) then
                   df = tcs%df(stateNum)
                else if (data_input%dicsop .eq. 2) then
                   if (en <0) then	
                      !excitation collision
	   	      df = tcs%df(stateNum)
                   else if (en >0) then
                      !Ionisation collision uses dissociative 
                      !ionisation cross sections.            
                      call getDissIonDf(dicsBasis, enIncident, df)
                   end if
                end if		


		! Random Number is selected between 0 and 1
		call RANDOM_NUMBER(randNum)
		
		! Sample to see if dissociation occurs
		if(randNum .lt. df) then
		   diss = .TRUE.
                   part%diss(coll) = 1
                else
                   part%diss(coll) = 0 
		end if		
		
		!print*, 'df = ', df
		!print*, 'randNum = ', randNum
		!print*, 'diss = ', diss
		part%diss(part%colls) = diss		
		if(diss .eqv. .true.) then ! Update how many dissociations have occured for this generation.
			datasim%dissPerGen(part%gen) = datasim%dissPerGen(part%gen) + 1
			datasim%dissociations = datasim%dissociations + 1
		end if
		!print*, 'diss tally ',datasim%dissPerGen(part%gen)
	
		
	end subroutine dissociation


	
	subroutine collectdata(datasim,maxgen,datamc)
	
	 implicit none
	 integer,intent(in):: maxgen
	 type(simdata),intent(in):: datasim
	 type(simdata),intent(inout):: datamc
	 integer:: i
	
	 datamc%secE = datamc%secE + datasim%secE
	 datamc%excite = datamc%excite + datasim%excite
	 datamc%elastic = datamc%elastic + datasim%elastic
	 datamc%gen = datamc%gen + datasim%gen
	 datamc%dissociations = datamc%dissociations + datasim%dissociations
	 
	 do i=1,maxgen
		datamc%ePerGen(i) = datamc%ePerGen(i) + datasim%ePerGen(i) 
		datamc%enPerGen(i) = datamc%enPerGen(i) + datasim%enPerGen(i)
	 end do	 
	 
	 do i=0,maxgen
		datamc%dissPerGen(i) = datamc%dissPerGen(i) + datasim%dissPerGen(i) 
		datamc%excPerGen(i) = datamc%excPerGen(i) + datasim%excPerGen(i) 
		datamc%elPerGen(i) = datamc%elPerGen(i) + datasim%elPerGen(i) 
		datamc%collPerGen(i) = datamc%collPerGen(i) + datasim%collPerGen(i) 
	 end do	 
	 
	 if(datasim%PsFormed) then
		datamc%numPsFormed = datamc%numPsFormed + 1
	 end if
	
         !Consistency check data
         do i =1, 1000
            datamc%numEj(i) = datamc%numEj(i) + datasim%numEj(i) 
         end do
 
	end subroutine collectdata
	
	subroutine printsim(simIndex,particlebasis,datasim,bmode)
	
		implicit none
		integer,intent(in):: simIndex
		type(particle),dimension(0:1000),intent(in):: particlebasis
		type(simdata),intent(in):: datasim
		logical,intent(in):: bmode ! True if Ps Benchmark Simulation is being done
		integer:: partNum,coll
	
		write(60,*) '-------------------------------- NEW SIMULATION ---------------------------'
		write(60,*) 'simIndex',simIndex
		do partNum=0, datasim%secE   
			if((.not. bmode) .or. (bmode.and.(partNum.eq.0))) then
				write(60,*) '--------NEW PARTICLE--------'
				write(60,*) 'particle',partNum,'gen',particlebasis(partNum)%gen
				do coll=0,particlebasis(partNum)%colls
					write(60,*) '-------'
					write(60,*) 'coll',coll,'state',particlebasis(partNum)%state(coll)
					write(60,*) 'precollE',particlebasis(partNum)%energy(coll),'postE', particlebasis(partNum)%energy(coll+1)	
					if(bmode) then
						write(60,*) 'Ps Formation = ', particlebasis(partNum)%Ps(coll)
					else
						write(60,*) 'diss = ', particlebasis(partNum)%diss(coll)
					end if
				end do
			end if
		end do
		write(60,*) 'ions',datasim%secE
		write(60,*) 'elastic', datasim%elastic
		write(60,*) 'excite',datasim%excite	
		
		
	end subroutine printsim


        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        !Subroutine: writePathToFile
        !Purpose: write the path of the incident particle and all secondaries
        !         to a csv file for plotting
        !Date last modified: 21/01/2021
        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        subroutine writePathToFile(simIndex,particlebasis,datasim,bmode)
            use input_data
            implicit none
             
 	    integer,intent(in):: simIndex
	    type(particle),dimension(0:1000),intent(in):: particlebasis
	    type(simdata),intent(in):: datasim
            logical,intent(in):: bmode ! True if Ps Benchmark Simulation is being done
            character(len=20)::simString, enString,pathString,cosString,phiString,dissString,stateNumString
            character(len=20)::partNumString
            character::inString 
            integer::ii,jj

            !Write particle path to file in order of creation. Collision event at which incident particle first
            !creates a secondary corresponds to event where first secondary in file is created.
            if (bmode) then


            else 
               write(simString,'(I0)') simIndex
               open(70, file="sim"//trim(simString)//".csv")

               write(70,*) "type,","Incident/Second,","EnSelected,","Radius(m),","costheta,","phi,","Diss,","StateNum,","partNum"               
               do ii = 0, datasim%secE
                  if (ii .eq. 0) then
                     inString = "i"
                  else
                     inString = "s"
                  end if
                    
                  do jj = 1, particlebasis(ii)%colls
                     write(enString,'(e13.5)') particlebasis(ii)%enArr(jj)
                     write(pathString,'(e13.5)') particlebasis(ii)%path(jj)
                     write(cosString,'(e13.5)') particlebasis(ii)%costheta(jj)
                     write(phiString,'(e13.5)') particlebasis(ii)%phi(jj)
                     write(stateNumString, '(i4)') particlebasis(ii)%state(jj)
                     write(partNumString, '(i4)') ii

                     write(70,*) adjustl("e,"),adjustl(trim(inString)),adjustl(","),adjustl(trim(enString)),adjustl(","),adjustl(trim(pathString)),adjustl(","),adjustl(trim(cosString)),&
                                 adjustl(","),adjustl(trim(phiString)),adjustl(","),particlebasis(ii)%diss(jj),adjustl(","),adjustl(trim(stateNumString)),adjustl(","),adjustl(partNumString)

                  end do
               end do
               close(70)
            end if
        end subroutine writePathToFile 





	
	subroutine simulationresults(datamc,totalSims,en_incident,maxgen,ionop,bmode,runTime,data_input)	
                use input_data
		implicit none

                type(input),intent(in)::data_input
		type(simdata),intent(in):: datamc
		integer,intent(in):: totalSims
		real*8,intent(in):: en_incident
		integer,intent(in):: maxgen
		character (len=60),intent(in):: ionop ! Ionistation option
		logical,intent(in):: bmode ! True if Ps Benchmark Simulation is being done
		integer:: i
                real*8::runTime
		real*8:: aveIons,aveExcites,aveElastics, avediss ! Average number of each collision type
		real*8:: aveGens ! Average number of generations created
		real*8,dimension(1000):: aveEperGen ! Average number of electrons per generation
		real*8,dimension(1000):: aveEnperGen ! Average number of electrons per generation
		real*8,dimension(0:1000):: avedissPerGen,aveexcPerGen,aveelPerGen,avecollPerGen ! Average number of dissociations per generation
		real*8:: fSurv ! Survival Fraction (only for Ps Benchmark Simulation)
		real*8:: aveTRes, eIon
                real*8:: wInv !1/(mean energy per ion pair)
                real*8, dimension(0:1000):: aveNumEj
                character (len=3):: enString
                !Total number of dissociations, etc over all secondary generations
                real*8:: aveIonTotal, aveDissTotal, aveExcTotal
                real*8:: aveElTotal, aveCollTotal, aveNumTotal, aveEnTotal
                
                eIon = 15.96632 !Ionisation energy of ground state H2 (eV)	
	
                !Initialises arrays to zero
                aveEperGen(:) = 0
                aveEnperGen(:) = 0
	

                open(unit=70,file='output.txt')
		
		aveIons = datamc%secE/float(totalSims)
		aveExcites = datamc%excite/float(totalSims)
		aveElastics = datamc%elastic/float(totalSims) 
		!aveEperGen = float(datamc%ePerGen(1))/float(totalSims)
		aveGens = float(datamc%gen)/float(totalSims)
		avediss = float(datamc%dissociations)/float(totalSims)
		
                !Calculate (1/mean energy per ion pair)
                if (en_incident .gt. eIon) then
                   wInv = aveIons/en_incident
                else
                   wInv = 0.0
                end if

	        write(70,*) 'program runtime(s)',runTime	
		write(70,*) 'inital particle energy (eV)', en_incident
		write(70,*) 'total number of simulations', totalSims
		if(bmode .eqv. .false.) then ! ionisation option only applies to default simulation
			write(70,*) 'ionisation treatment: ', ionop
		end if
		! write(70,*) 'totalIons',datamc%secE,'aveIons',aveIons
		! write(70,*) 'totalExcites',datamc%excite,'aveExcites',aveExcites
		! write(70,*) 'totalElastics',datamc%elastic,'aveElastics',aveElastics
		! write(70,*) 'totaldiss',datamc%dissociations,'avediss',avediss
		
		write(70,*) 'ave collisional ionisations',aveIons
		write(70,*) 'ave collisional excitations',aveExcites
		write(70,*) 'ave elastic collisions',aveElastics
		if(.NOT. bmode) then
			write(70,*) 'ave dissociations',avediss
		end if
		
		if(bmode) then ! Ps Formation Benchmark Run
			fSurv = 100 * (1 - float(datamc%numPsFormed)/float(totalSims))
			write(70,*) 'fSurv: ', fSurv
			write(70,*) 'datamc%numPsFormed: ', datamc%numPsFormed
			aveTRes = datamc%tRes / (float(totalSims) - float(datamc%numPsFormed))
			write(70,*) 'TRes: ', aveTRes
		else ! Default Simulation Run
			write(70,*) 'highest number of generations', maxgen
			write(70,*) 'ave number of generations', aveGens 
                        write(70,*) 'reciprocal of mean energy per ion pair:', wInv		
	
			do i=1,maxgen
     		                aveEperGen(i) = float(datamc%ePerGen(i)) / float(totalSims)
				aveEnperGen(i) = datamc%enPerGen(i) / float(datamc%ePerGen(i))	
			end do
			
			do i=0,maxgen
				write(70,*) '------------------------------------------------------------'
				write(70,*) 'generation:',i
				if(i .gt. 0) then					
					write(70,*) 'ave number of electrons:',aveEperGen(i)!,datamc%ePerGen(i)!,&
					write(70,*) 'ave energy of electrons (eV):',aveEnperGen(i)
				end if 
				avedissPerGen(i) = float(datamc%dissPerGen(i)) / float(totalSims)
				aveexcPerGen(i) = float(datamc%excPerGen(i)) / float(totalSims)
				aveelPerGen(i) = float(datamc%elPerGen(i)) / float(totalSims)
				avecollPerGen(i) = float(datamc%collPerGen(i)) / float(totalSims)
				write(70,*) 'ave number of ionisation collisions:',aveEperGen(i+1)				
				write(70,*) 'ave number of excitation collisions:', aveexcPerGen(i)				
				write(70,*) 'ave number of elastic collisions:', aveelPerGen(i)				
				write(70,*) 'ave number of collisions:',avecollPerGen(i)
				write(70,*) 'ave number of dissociations:', avedissPerGen(i)
			end do	 
  
                        aveNumTotal = 0.0 
                        aveEnTotal = 0.0
                        aveIonTotal = 0.0
                        aveDissTotal = 0.0
                        aveExcTotal = 0.0
                        aveElTotal = 0.0
                        aveCollTotal = 0.0

                        !Print results for secondary electrons overall 
                        do i =1,maxgen
                           aveNumTotal = aveNumTotal + aveEPerGen(i)
                           aveEnTotal = aveEnTotal + aveEnPerGen(i) 
                           aveIonTotal = aveIonTotal + aveEPerGen(i+1)
                           aveDissTotal = aveDissTotal + float(datamc%dissPerGen(i))
                           aveExcTotal = aveExcTotal + float(datamc%excPerGen(i))
                           aveElTotal = aveElTotal + float(datamc%elPerGen(i))
                           aveCollTotal = aveCollTotal + float(datamc%collPerGen(i))
                        end do	
                         

                        aveDissTotal = aveDissTotal/float(totalSims)
                        aveExcTotal = aveExcTotal/float(totalSims)
                        aveElTotal = aveElTotal/float(totalSims) 
                        aveCollTotal = aveCollTotal/float(totalSims)
                        write(70,*) '------------------------------------------------'
                        write(70,*) 'secondary total:'
                        write(70,*) 'ave number of electrons:', aveNumTotal 
                        write(70,*) 'ave energy of electrons (eV):', aveEnTotal
	                write(70,*) 'ave number of ionisation collisions:',aveIonTotal		
			write(70,*) 'ave number of excitation collisions:', aveExcTotal				
			write(70,*) 'ave number of elastic collisions:', aveElTotal		
			write(70,*) 'ave number of collisions:',aveCollTotal
			write(70,*) 'ave number of dissociations:', aveDissTotal
		end if
		
		
		!!!!!!!!!!!!!!!!!!!!!!!! NICE FORMAT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		if(.NOT. bmode) then ! Outputs only for Default Sim
			write(70,*) '------------------------------------------------'
			write(70,*) '------------------------------------------------'
			write(70,*) 'ions: total, gen0,gen1,etc'
			write(70,*) aveIons
			do i=0,maxgen-1
				write(70,*) aveEperGen(i+1)				
                        end do
            		
	
			write(70,*) 'exc: total, gen0,gen1,etc'
			write(70,*) aveExcites
			do i=0,maxgen
				write(70,*) aveexcPerGen(i)				
			end do	
			
			write(70,*) 'el: total, gen0,gen1,etc'
			write(70,*) aveElastics
			do i=0,maxgen
				write(70,*) aveelPerGen(i)			
			end do
			
			write(70,*) 'colls: gen0,gen1,etc'
			do i=0,maxgen
				write(70,*) avecollPerGen(i)			
			end do
			
			write(70,*) 'diss: total, gen0,gen1,etc'
			write(70,*) avediss
			do i=0,maxgen
				write(70,*) avedissPerGen(i)	
			end do 
			
			write(70,*) 'enpergen: gen0,gen1,etc'
			do i=0,maxgen -1
				write(70,*) aveEnperGen(i+1)
			end do
		end if
                close(70)		

                !Writes consistency check data to separate file for plotting
                if (.not. bmode) then
                   if ((ionop .eq. "SDCS") .or. (ionop .eq. "state_distribution")) then
                      aveNumEj(:) = float(datamc%numEj(:))/float(totalSims) 
                      write(enString,'(I0)') int(data_input%energyeV)
                      if (ionop .eq. 'SDCS') then
                        open(70, file = "numEjAtEnSDCS"//trim(enString)//".txt")
                      else if (ionop .eq. "state_distribution") then
                         open(70, file = "numEjAtEnDist"//trim(enString)//".txt")
                      end if
                    
                      write(70,*) "Ejection Energy (ev)           Ave Number Ejected"
                      do i = 1,1000
                         write(70,*) datamc%ejEnGrid(i), aveNumEj(i)
                      end do
                      close(70)
                   end if
                end if
	end subroutine simulationresults	
	
	subroutine meanexcendist(statebasis)
		use totalcs_module
		use state_class
		implicit none
		type(basis_state),intent(in):: statebasis
		type(totalcs):: tcs 
		real*8:: meanexc,en_incident
		
		print*, 'creating secondary electron energy distribution (file=secEenergydist)'
		
		en_incident = 15.96632 !(eV)
		
		open(unit=90,file='secEenergydist')
		!write(90,*) 'en_incident	','meanexc	','meansecE'
		do while(en_incident .LE. 700)
			call get_csatein(statebasis,en_incident,tcs) ! Create totalcs for the current energy !call print_tcs(tcs) 
			call meanexcenergy(tcs,statebasis,meanexc)
			write(90,*) en_incident, meanexc-15.96632
			en_incident = en_incident + 0.001
		end do
		close(90)
	end subroutine meanexcendist
	
	subroutine elasticScattering(en_incident,costheta, elEnergyLoss,bmode,dcsBasis)
                use input_data 
                use dcs_module 
		implicit none
		real*8,intent(in):: en_incident	  	  ! initial energy of incident particle (eV)
		real*8,intent(out):: elEnergyLoss	  ! energy lost by incident particle (eV)
		real*8:: mParticle,mTarget 			  ! mass of particle and target (kg)
		real*8,intent(in):: costheta			  ! cosine of scattering angle (RADIANS)
		real*8:: th,randNum
		real*8:: PI, totalcsval
		logical,intent(in):: bmode
                type(basis_dcs)::dcsBasis
                type(dcs)::dcsEn
		
		PI = 4.D0*DATAN(1.D0)
		
		if(.NOT. bmode) then ! Run Default Simulation
			mParticle = 9.10938356E-31		! mass of electron (kg)
			!mParticle = 9.1093835D-31
			mTarget = 2 * 1.6726219E-27		! mass of H2 molecule (kg), assuming it is 2 * mass of proton			
	
                        if (data_in%momOp .eq. 0) then
                           !use inelastic scattering energy loss formula	
			   elEnergyLoss = (2*mParticle*mTarget)/((mParticle+mTarget)*(mParticle+mTarget))*en_incident*(1-costheta)
			   !print*, 'theta',theta*PI/180,'factor',(4*mParticle*mTarget)/((mParticle+mTarget)*(mParticle+mTarget))*(sin((theta*PI/180)/2))*(sin((theta*PI/180)/2))
		   	   !elEnergyLoss = (3.6E-4) * en_incident
                        else if (data_in%momOp .eq. 1) then
                           !Use momentum transfer cross sections to get average energy loss
                           call get_dcsatein(dcsBasis,en_incident,dcsEn)
                           elEnergyLoss = 2*((mParticle*mTarget)/(mParticle+mTarget)**2)*en_incident*dcsEn%momtcs/dcsEn%intCs
                           call delete_dcs(dcsEn) 
                        end if
		else
			! Random Number is selected between 0 and 1
			call RANDOM_NUMBER(randNum)
			th = 180.0 * randNum
			mParticle = 9.10938356E-31		! mass of positron (kg)
			!mParticle = 9.11E-31		! mass of positron (kg)
			!mTarget = 1.6735575E-27		! mass of atomic H (kg)
			mTarget = 1.6726219E-27		! mass of H atom (kg), assuming it is mass of proton
			elEnergyLoss = (4*mParticle*mTarget)/((mParticle+mTarget)*(mParticle+mTarget))*en_incident*(sin(th/2))*(sin(th/2))			
		end if
		
		
		
		!print*, 'mParticle*1E31',mParticle*1E31
		
	end subroutine elasticScattering
!
!

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !Subroutine: inelasticScattering
    !Purpose: calculates the recoil energy loss in an inelastic collision
    !Date last modified: 29/02/2020
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    subroutine inelasticScattering(en_incident, enex, costheta, energyLoss, bmode )
        real*8,intent(in):: en_incident	  	  ! initial energy of incident particle (eV)
        real*8,intent(out):: energyLoss	  ! energy lost by incident particle (eV)
	real*8:: mParticle,mTarget 			  ! mass of particle and target (kg)
	real*8,intent(in):: costheta			  ! cosine of scattering angle (RADIANS)
        logical::bmode
        real*8:: enex  !Excitation/internal energy
        real*8::en, sqrtVal

        en = en_incident

        !When generalising, masses will be input variables.
        if (bmode) then
           !Positronium benchmark mode
           mTarget = 2 * 1.6726219E-27   ! mass of H2 molecule (kg), assuming it is 2 * mass of proton			
           mParticle = 9.10938356E-31   ! mass of positron (kg)
           energyLoss = en*((2*mTarget*mParticle)/((mTarget+mParticle)**2) + &
                            enex/(en*(1+(mParticle/mTarget))) - &
                            (2*mParticle*costheta/(mParticle+mTarget))*sqrt((mTarget/(mTarget+mParticle))**2 &
                            - enex/(en*(1+mParticle/mTarget))))
        else
           !Default simulation 
           mTarget = 2 * 1.6726219E-27   ! mass of H2 molecule (kg), assuming it is 2 * mass of proton			
           mParticle = 9.10938356E-31   ! mass of electron (kg) 
           sqrtVal =  (mTarget/(mTarget+mParticle))**2 - enex/(en*(1.0+mParticle/mTarget))
           if (sqrtVal .gt. 0.0) then
              energyLoss = en*((2.0*mTarget*mParticle)/((mTarget+mParticle)**2) + &
                            enex/(en*(1.0+(mParticle/mTarget))) - &
                            (2.0*mParticle*costheta/(mParticle+mTarget))*sqrt((mTarget/(mTarget+mParticle))**2 &
                            - enex/(en*(1.0+mParticle/mTarget)))) 
           else
              print*, "SQRTVAL: ", sqrtVal
              print*, "ENEX, EIN: ", enex, en
              print*, "ERROR: ratio excitationEn/eIncident .gt. 1/(1+mParticle/mTarget), stopping"
              stop
           end if
        end if
    end subroutine inelasticScattering








 subroutine selectstate(tcs,part,coll,stateNum)
     use input_data
     use totalcs_module 
	
     implicit none 
     integer, intent(in):: coll
     type(totalcs), intent(in):: tcs
     type(particle), intent(inout):: part ! The current particle
     integer,intent(out):: stateNum
     real*8, dimension(:),allocatable:: stateprob
     real*8:: randNum, sigma, den 
     integer:: i

     !Density of the medium, set in input file.	
     !den = data_in%density 

     ! stateprob is cumulative probabilty for each state
     call normalisetcs(tcs,stateprob)
	
     ! Random Number is selected between 0 and 1
     call RANDOM_NUMBER(randNum)
	
     ! Determines which state (the 'i'th process in the array) is selected
     i = 1
     do while (stateprob(i) .le. randNum)
        i = i + 1		
     end do    
	
     ! Ensures that the state is valid
     ! Due to numerical accuracy,stateprob(tcs%Nmax) may be less than 1.0
     if(i .lt. tcs%Nmax) then
        stateNum = i
     else
        stateNum = tcs%Nmax
     end if

     part%state(coll) = stateNum ! records the state chosen at this collision for this particle
     if (tcs%en(i) .gt. 0.0) then
        !print*, tcs%en(i) 
     end if	


     !print*, 'randNum',randNum
     ! ! Be careful printing this next line if stateNum=1
     if(stateNum .eq. 1) then
     !print*,'stateprob(stateNum)',stateprob(stateNum)
     else
     !print*,'stateprob(stateNum)',stateprob(stateNum),'stateprob(stateNum-1)',stateprob(stateNum-1)
     end if
     !print*, 'stateNum =',stateNum

     !Convert cross section to SI units, density in 1/m^3
     sigma = tcs%CS(stateNum)*(data_in%bohrRadius)**2 
     part%path(coll) = 1.0/(den*sigma)

     deallocate(stateprob) !deallocate variable allocated in 'normalisetcs' 
	
  end subroutine selectstate




 subroutine selectVcsState(vcsIn,part,coll,enex,stateBasis,minExcEn)
     use totalcs_module 
     use state_class	

     implicit none 
     integer, intent(in):: coll
     type(vcs), intent(in):: vcsIn
     type(totalcs)::tcsOb
     type(basis_state)::stateBasis
     type(particle), intent(inout):: part ! The current particle
     integer:: stateNum
     real*8, dimension(:),allocatable:: stateprob
     real*8:: randNum, sigma, den, minExcEn
     real*8, intent(out)::enex
     integer:: i
	
     den = 1 !To be replaced with Danny's suggested number density

     ! stateprob is cumulative probabilty for each state
     call normaliseVcs(vcsIn,stateprob)
	
     ! Random Number is selected between 0 and 1
     call RANDOM_NUMBER(randNum)
	
     ! Determines which state (the 'i'th process in the array) is selected
     i = 1
     if (sum(stateprob) .gt. 0.0) then
        !Probability is non-zero
        do while (stateprob(i) .le. randNum)
           i = i + 1		
        end do    
     else 
        i=1 !Stays in ground state
     end if
	
     ! Ensures that the state is valid
     ! Due to numerical accuracy,stateprob(vcsBasis%numVcs) may be less than 1.0
     if(i .lt. vcsIn%nvf) then
        stateNum = i
     else
        stateNum = vcsIn%nvf
     end if

     if(i .gt. 1) then
        sigma = vcsIn%cs(stateNum)
     else
        !Need a physically reasonable choice for sigma. Below is included to 
        !get vcs running.
 
        !Use elastic scattering CS in case of vf = 0
        if (sum(stateprob) .gt. 0.0) then 
           sigma = vcsIn%cs(i)
        else
           call get_csatein(stateBasis,minExcEn,tcsOb)
           sigma = tcsOb%cs(1)
           call delete_totalcs(tcsOb)
        end if            
     end if

     part%path(coll) = 1.0/(den*sigma)
     enex = vcsIn%en(stateNum)

     deallocate(stateprob) !deallocate variable allocated in 'normaliseVcs' 
	
  end subroutine selectVcsState







  
  SUBROUTINE timeElapsed(energy,stateNum,crossSection,VarPs,datasim)

	use Ps_module
	
	IMPLICIT NONE
	REAL, INTENT(IN) :: energy
	INTEGER, INTENT(IN) :: stateNum
	type(PsVar), intent(in) :: VarPs
	REAL*8 :: m_p, eVToJoules, velocity, constant, con2, m
	real*8, intent(in) :: crossSection
	!REAL*8, INTENT(OUT) :: duration
	type(simdata),intent(inout):: datasim
	
	m_p = 	9.109E-31 
	m = 9.1093897
	
	m_p = 9.10938356E-31 ! mass of positron
	
	eVToJoules = 1.60218E-19
	
	
		
	! IF(stateNum .EQ. 4) THEN
		! crossSection = VarPs%cs_Ps
	! ELSE IF(stateNum .EQ. 1) THEN
		! crossSection = VarPs%cs_el
	! ELSE IF(stateNum .EQ. 3) THEN
		! crossSection = VarPs%cs_ion
	! ELSE IF(stateNum .EQ. 2) THEN
		! crossSection = VarPs%cs_exc
	! ELSE 
		! !crossSection = 0.0
	! END IF
	
	! Convert Cross section from A^2 to m^2
	!crossSection = crossSection * 10**(-20)
	
	! constant is equal to eVToJoules/m_p
	constant = 1.7565E11
	
	con2 = 1!*10**(14)
	
	!velocity = (2 * energy * eVToJoules / m_p) ** (0.5)
	
	!duration = 1 / (crossSection * velocity)	
	
	!duration = ((m_p)**(1/2)) / (crossSection * ((2 * energy * eVToJoules)**(1/2)))
	!duration = ((m_p)**(1/2)) / (((2 * energy * eVToJoules)**(1/2)))
	
	!duration = (m**0.5)/((2*energy * 1.60218)**(0.5) * crossSection) / 10 ! in terms of s*m^-3 * 10^15
	!duration = ((m/(2*energy*1.60218))**(0.5))/(crossSection*10*3.2) ! in terms of s*m^-3 * 10^15
	
	! THis is what I had before the update
	!velocity = (2 * energy * constant) ** (0.5)
	!duration = ((m/(2*energy*1.602176565))**(0.5))/(crossSection*10) ! in terms of s*m^-3 * 10^15
	
	
	
	! Update 03/07/2019 !
	
	datasim%duration = 10E15 * sqrt(m_p / (2*energy*eVToJoules)) * 10E20 / crossSection ! puts it into 10^15 form?
	datasim%duration = sqrt(m_p / (2*energy*eVToJoules)) * 10E20 / crossSection ! unaltered
	datasim%duration = 10E-15 * sqrt(m_p / (2*energy*eVToJoules)) * 10E20 / crossSection ! altered?
	!print*, 'duration', datasim%duration
	
	!write(2,*) 'vel', velocity, 'cs', crossSection, 'energy', energy, 'duration', duration
	
  END SUBROUTINE timeElapsed


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !Subroutine: selectAngle
  !Purpose: selects a scattering angle (cos(theta)) from cross sections
  !         differential in solid angle (dcs)
  !Date last modified: 06/07/2020
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  SUBROUTINE selectAngle(eldcs,eIncident,costheta)
     use dcs_module
     implicit none
     type(basis_dcs), intent(in)::eldcs
     real*8, intent(in)::eIncident 
     real*8, intent(out)::costheta 
     type(dcs)::dcsBelow, dcsAbove
     integer::ii, numPoints, indexVal
     real*8::total, thetaK, randNum
     real*8, allocatable, dimension(:)::sums !array of partial sums 
     real*8, allocatable, dimension(:)::dcsArray !array of dcs at incident energy
     real*8::intp1, intp2, intp3 !Used to break up long interpolation formula

     !Finds dcs for above and below given incident energy
     ii =1
     do while( (ii .le. eldcs%Ndcs) .and. (eldcs%ein(ii) .lt. eIncident) )
        ii = ii +1
     end do
     dcsBelow = eldcs%dcsbasis(ii-1)    
     dcsAbove = eldcs%dcsbasis(ii)

     allocate(sums(dcsBelow%Nth), dcsArray(dcsBelow%Nth))
   
     do ii = 1, dcsBelow%Nth
        !Interpolates to find cross sections at given energy.
        intp1 = (eIncident-dcsBelow%en_incident)
        intp2 = (dcsAbove%dcs(ii)-dcsBelow%dcs(ii))
        intp3 = (dcsAbove%en_incident-dcsBelow%en_incident)
        dcsArray(ii) = dcsBelow%dcs(ii) + intp1*(intp2/intp3)
     end do

     !Computes total cross section
     call getSum(dcsArray, dcsBelow%Nth, total) 

     !Constructs distribution.      
     sums = 0.d0 !Initialises array
     numPoints = dcsBelow%Nth !Number of cross sections, also num angle points
     sums(1) = (dcsArray(1)/total)
     do ii = 2, numPoints
        sums(ii) = sums(ii-1) + (dcsArray(ii)/total)
        !print*, "SUM, ANGLE: ", sums(ii), dcsBelow%theta(ii)
     end do

     !Generates random number
     call RANDOM_NUMBER(randNum)
     ii = 1          
     do while (sums(ii) .lt. randNum)
        ii = ii + 1
     end do

     !Selected angle
     costheta = cos(dcsBelow%theta(ii)) 


     deallocate(sums, dcsArray)

  END SUBROUTINE selectAngle



 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !Subroutine: getSum
 !Purpose: sums over differential cross sections in imported array
 !Date last modified: 27/03/2020
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 subroutine getSum(dcsArrIn, Ndcs, total)
    implicit none
    real*8, dimension(:), intent(in)::dcsArrIn
    real*8::total
    integer::ii, Ndcs

    !Sums differential cross sections
    total = 0
    do ii = 1, Ndcs
       total = total + dcsArrIn(ii)
    end do

 end subroutine getSum






 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !Subroutine: selectEjEn
 !Purpose: selects an ejection energy for secondary
 !         electrons from sdcs, defined over 2D
 !         fine energy grid.
 !Date last modified: 06/05/2020
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 subroutine selectEjEn(sdcsAtEIn, ejEn)
    use sdcs_module
    implicit none
    type(sdcs)::sdcsAtEIn
    real*8::ejEn !Selected ejection energy
    real*8, allocatable, dimension(:)::enProb
    real*8::randNum !Uniform random number
    integer::enNum, ii

    !Construct cumulative distribution
    call normalisesdcs(sdcsAtEIn, enProb)

    !Select energy
    call RANDOM_NUMBER(randNum)

    !Find selected state
    ii = 1
    do while (enProb(ii) .lt. randNum)
       ii = ii +1
    end do

    !Account for rare case when eIncident -eIon < deltaE, where deltaE is the
    !grid step size. 
    if (int(enProb(1)) .eq. 2) then
       !Normalisesdcs sets enProb(1) to 2 when this occurs       
       ejEn = sdcsAtEIn%ecg(2) - sdcsAtEIn%ecg(1) !Ensures no further events can occur. 
    else
       !Check validity
       if (ii .lt. sdcsAtEIn%Ncgsdcs) then
          enNum = ii
       else
          enNum = sdcsAtEIn%Ncgsdcs
       end if
       ejEn = sdcsAtEIn%ecg(enNum)
    end if 
    deallocate(enProb) 
 end subroutine selectEjEn









end module mc
